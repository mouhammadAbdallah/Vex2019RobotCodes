#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    myGyro,         sensorGyro)
#pragma config(Sensor, in2,    clawsPot,       sensorPotentiometer)
#pragma config(Sensor, in3,    backLim,        sensorLineFollower)
#pragma config(Sensor, in4,    frontLim,       sensorLineFollower)
#pragma config(Sensor, dgtl1,  craneEnc,       sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  RightBump,      sensorTouch)
#pragma config(Sensor, dgtl4,  LeftBump,       sensorTouch)
#pragma config(Sensor, dgtl5,  AdjtSwitch,     sensorTouch)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           MobGoalntake,  tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           frontRight1,   tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           frontLeftExp,  tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           rightClaws,    tmotorVex393TurboSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           backRight,     tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           backLeft,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           leftClaws,     tmotorVex393TurboSpeed_MC29, openLoop)
#pragma config(Motor,  port8,           craneMotorsExp, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           frontRight2,   tmotorVex393_MC29, openLoop, reversed, encoderPort, I2C_1)
#pragma config(Motor,  port10,          rollerMotor,   tmotorVex393_HBridge, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX2)

#pragma competitionControl(Competition)

#include "Vex_Competition_Includes.c"

#define MOTOR_NUM               kNumbOfTotalMotors
#define MOTOR_MAX_VALUE         127
#define MOTOR_MIN_VALUE         (-127)
#define MOTOR_DEFAULT_SLEW_RATE 30      // Default will cause 375mS from full fwd to rev
#define MOTOR_FAST_SLEW_RATE    256     // essentially off
#define MOTOR_TASK_DELAY        20      // task 1/frequency in mS (about 66Hz)
#define MOTOR_DEADBAND          10


void moveClawsTo(int clawsTar);
void moveClawsWith(int speed);
void moveCraneWith(int speed);
void moveCraneTo(int craneTar);
void moveRobot(int RSpeed, int LSpeed);
void turnRollerToEject();
void turnRollerToEat();

int motorReq[MOTOR_NUM];
int motorSlew[MOTOR_NUM];

int Err = 0;
int c = 0;
int thresh = 1700;
bool MobInUp = false;
bool MobInDown = false;
task MotorSlewRateTask()
{
	int motorIndex;
	int motorTmp;


	// Initialize stuff
	for (motorIndex = 0; motorIndex < (signed)MOTOR_NUM; motorIndex++)
	{
		motorReq[motorIndex] = 0;
		motorSlew[motorIndex] = MOTOR_DEFAULT_SLEW_RATE;
	}

	// run task until stopped
	while (true)
	{
		// run loop for every motor
		for (motorIndex = 0; motorIndex < (signed)MOTOR_NUM; motorIndex++)
		{
			// So we don't keep accessing the internal storage
			motorTmp = motor[motorIndex];

			// Do we need to change the motor value ?
			if (motorTmp != motorReq[motorIndex])
			{
				// increasing motor value
				if (motorReq[motorIndex] > motorTmp)
				{
					motorTmp += motorSlew[motorIndex];
					// limit
					if (motorTmp > motorReq[motorIndex])
						motorTmp = motorReq[motorIndex];
				}

				// decreasing motor value
				if (motorReq[motorIndex] < motorTmp)
				{
					motorTmp -= motorSlew[motorIndex];
					// limit
					if (motorTmp < motorReq[motorIndex])
						motorTmp = motorReq[motorIndex];
				}

				// finally set motor
				motor[motorIndex] = motorTmp;
			}
		}

		// Wait approx the speed of motor update over the spi bus
		wait1Msec(MOTOR_TASK_DELAY);
	}
}

void pre_auton()
{
	bStopTasksBetweenModes = true;
	SensorValue[craneEnc] = 0;
	SensorValue[myGyro] = 0;
	nMotorEncoder[frontRight2] = 0;

}


task autonomous()
{
	startTask(MotorSlewRateTask);
	nMotorEncoder[frontRight2] = 0;
	clearTimer(T1);
	while(nMotorEncoder[frontRight2] < 1700)
	{
		moveRobot(60,60);

		if(time1(T1) < 800)
		{
			motorReq[MobGoalntake] = -127;
		}
		else
		{
			motorReq[MobGoalntake] = 0;
		}
	}
	moveRobot(0,0);
	motorReq[MobGoalntake] = 0;
	clearTimer(T1);
	while(time1(T1)<1000)
	{
		motorReq[MobGoalntake] = 127;
	}
	motorReq[MobGoalntake] = 0;
	clearTimer(T1);
	while(time1(T1) < 500)
	{
		turnRollerToEject();
	}
	motorReq[rollerMotor] = 0;
	while(SensorValue[myGyro] > -1600)
	{
		moveRobot(-60,60);
	}
	moveRobot(0,0);
	Err = 0;
	clearTimer(T1);
	while(time1(T1)<800)
	{
		Err = SensorValue[myGyro] + 1800;
		moveRobot(-0.3*Err,0.3*Err);
	}
	moveRobot(0,0);
	nMotorEncoder[frontRight2] = 0;
	Err = 0;
	c = 0;
	while(SensorValue[frontLim] >thresh || nMotorEncoder[frontRight2] < 500)
	{
		Err = SensorValue[myGyro] + 1800;
		moveRobot(60 - 0.3*Err,60 + 0.3*Err);
	}
	moveRobot(0,0);
	nMotorEncoder[frontRight2] = 0;
	clearTimer(T1);
	while(nMotorEncoder[frontRight2] > -100)
	{
		moveRobot(-60,-60);
		if(time1(T1)< 100)
			motorReq[MobGoalntake] = 127;
		else
		{
			motorReq[MobGoalntake] = 0;
		}
	}
	motorReq[MobGoalntake] = 0;
	while(SensorValue[myGyro] < -1500)
	{
		moveRobot(60,-60);
	}
	moveRobot(0,0);
	Err = 0;
	clearTimer(T1);
	while(time1(T1) < 1000)
	{
		Err = SensorValue[myGyro] + 1350;
		moveRobot(-0.3*Err,0.3*Err);
	}
	moveRobot(0,0);
	nMotorEncoder[frontRight2] = 0;
	Err = 0;
	c = 0;
	while(nMotorEncoder[frontRight2]<800)
	{
		Err = SensorValue[myGyro] + 1350;
		moveRobot(60 - 0.3*Err,60 + 0.3*Err);
	}
	moveRobot(0,0);
	while(SensorValue[myGyro] > -1600)
	{
		moveRobot(-60,60);
	}
	moveRobot(0,0);
	Err = 0;
	clearTimer(T1);
	while(time1(T1) < 800)
	{
		Err = SensorValue[myGyro] + 1800;
		moveRobot(-0.3*Err,0.3*Err);
	}
	moveRobot(0,0);
	clearTimer(T1);
	while(time1(T1) < 1200)
	{
		moveRobot(127,127);
		if(time1(T1) > 600)
		{
			motorReq[MobGoalntake] = -127;
		}
	}
	motorReq[MobGoalntake]  = 0;
	moveRobot(0,0);
	clearTimer(T1);
	while(time1(T1) < 300)
	{
		moveRobot(-127,-127);
	}
	moveRobot(0,0);
	clearTimer(T1);
	while(time1(T1) < 400)
	{
		moveRobot(127,127);
	}
	motorReq[MobGoalntake] = 0;
	moveRobot(0,0);
	clearTimer(T1);
	while(time1(T1) < 300)
	{
		moveRobot(-127,-127);
	}
	moveRobot(0,0);
	clearTimer(T1);
	while(time1(T1) < 400)
	{
		moveRobot(127,127);
		motorReq[MobGoalntake] = -127;
	}
	motorReq[MobGoalntake] = 0;
	moveRobot(0,0);
	nMotorEncoder[frontRight2] = 0;
	clearTimer(T1);
	while(time1(T1) < 600)
	{
		motorReq[MobGoalntake] = 127;
	}
	motorReq[MobGoalntake] = 0;

	while(abs(nMotorEncoder[frontRight2]) < 700 && SensorValue[backLim] > thresh)
	{
		if(abs(nMotorEncoder[frontRight2])> 100)
		{
			motorReq[MobGoalntake] = -127;
		}
		else
		{
			motorReq[MobGoalntake] = 0;
		}
		moveRobot(-60,-60);
	}
	moveRobot(0,0);
	clearTimer(T1);
	while(time1(T1) < 600)
	{
		motorReq[MobGoalntake] = 127;
	}
	motorReq[MobGoalntake] = 0;
	SensorValue[myGyro] = 0;
	while(SensorValue[myGyro] > -600)
	{
		moveRobot(-60,60);
	}
	moveRobot(0,0);
	Err = 0;
	clearTimer(T1);
	while(time1(T1) < 800)
	{
		Err =SensorValue[myGyro] + 900;
		moveRobot(-0.3*Err,0.3*Err);
	}
	moveRobot(0,0);
	nMotorEncoder[frontRight2] = 0;
	Err = 0;
	moveRobot(0,0);
	while(SensorValue[AdjtSwitch] == 0)
	{
		Err = SensorValue[myGyro] + 900;
		moveCraneTo(150);
		moveRobot(-30 - 0.3*Err,-30 + 0.3*Err);
		delay(10);
	}
	moveRobot(0,0);
	while(SensorValue[myGyro] > -1300)
	{
		moveCraneTo(150);
		moveRobot(-60,0);
	}
	clearTimer(T1);
	while(true)
	{
		moveCraneTo(150);
		moveRobot(-60,-60);
		if(time1(T1)>250)
		{
			break;
		}
	}
	moveRobot(0,0);
	moveCraneWith(0);
	nMotorEncoder[frontRight2] = 0;
	SensorValue[myGyro] = 0;
	while(nMotorEncoder[frontRight2] < 300)
	{
		moveRobot(50,50);
	}
	moveRobot(0,0);
	clearTimer(T1);
	while(time1(T1)<1000)
	{
		moveCraneTo(0);
	}
	moveCraneWith(0);
	clearTimer(T1);
	Err = 0;
	while(time1(T1)<500)
	{
		motorReq[MobGoalntake] = -127;
	}
	motorReq[MobGoalntake] = 0;
	moveRobot(0,0);
	Err=0;
	nMotorEncoder[frontRight2] = 0;
	while(nMotorEncoder[frontRight2] < 1200)
	{
		Err = SensorValue[myGyro] + 100;
		//Err = SensorValue[myGyro];
		moveRobot(60 - 0.3*Err,60 + 0.3*Err);
	}
	moveRobot(0,0);
	moveCraneWith(0);
	nMotorEncoder[frontRight2] = 0;
	clearTimer(T1);
	//while(nMotorEncoder[frontRight2] < 1200)
	//{
	//	Err = SensorValue[myGyro];
	//	moveRobot(60 - 0.3*Err,60 + 0.3*Err);
	//	//if(time1(T1) < 800)
	//	//{
	//	//	motorReq[MobGoalntake] = -127;
	//	//}
	//	//else
	//	//{
	//	//	motorReq[MobGoalntake] = 0;
	//	//}
	//}
	moveRobot(0,0);
	clearTimer(T1);
	while(time1(T1)< 1000)
	{
		motorReq[MobGoalntake] = 127;
	}
	motorReq[MobGoalntake] = 0;
	moveRobot(0,0);
	while(SensorValue[myGyro] < 1200)
	{
		moveRobot(60,-60);
	}
	moveRobot(0,0);
	Err = 0;
	clearTimer(T1);
	while(time1(T1)<800)
	{
		Err = SensorValue[myGyro] - 1350;
		moveRobot(-0.3*Err,0.3*Err);
	}
	moveRobot(0,0);
	Err = 0;
	while(SensorValue[frontLim] > thresh)
	{
		Err = SensorValue[myGyro] - 1350;
		moveRobot(60 - 0.3*Err,60 + 0.3*Err);
	}
	moveRobot(0,0);
	clearTimer(T1);
	while(time1(T1) < 2000)
	{
		moveRobot(25,25);
	}
	moveRobot(0,0);
	clearTimer(T1);
	while(time1(T1) < 1000)
	{
		motorReq[MobGoalntake] = -127;
	}
	motorReq[MobGoalntake] = 0;
	SensorValue[myGyro] = 0;
	nMotorEncoder[frontRight2] = 0;
	while(nMotorEncoder[frontRight2] > -200)
	{
		moveRobot(-50,-50);
	}
	moveRobot(0,0);
	clearTimer(T1);
	while(time1(T1) < 1000)
	{
		motorReq[MobGoalntake] = 127;

	}
	motorReq[MobGoalntake] = 0;
	Err = 0;
	while(SensorValue[myGyro]>-700)
	{
		moveRobot(-60,60);
	}
	clearTimer(T1);
	while(time1(T1) < 800)
	{
		Err = SensorValue[myGyro] + 900;
		moveRobot(-0.3*Err,0.3*Err);
		moveCraneTo(150);
	}
	motorReq[MobGoalntake] = 0;
	moveRobot(0,0);
	Err = 0;
	while(SensorValue[AdjtSwitch] == 0)
	{
		moveRobot(-60 - 0.3*Err,-60 + 0.3*Err);
		moveCraneTo(150);
	}
	while(SensorValue[myGyro] > -1300)
	{
		moveRobot(-60,0);
		moveCraneTo(150);
	}
	moveRobot(0,0);
	clearTimer(T1);
	while(true)
	{
		moveRobot(-60,-60);
		moveCraneTo(150);
		if(time1(T1) > 250)
		{
			break;
		}
	}
	moveRobot(0,0);
	SensorValue[myGyro] = 0;
	nMotorEncoder[frontRight2] = 0;
	while(nMotorEncoder[frontRight2] < 550)
	{
		moveRobot(60,60);
		moveCraneTo(150);
	}
	moveRobot(0,0);
	moveCraneWith(0);
	clearTimer(T1);
	while(time1(T1) < 800)
	{
		moveCraneTo(0);
	}
	moveCraneWith(0);
	while(SensorValue[myGyro] > -700)
	{
		moveRobot(-60,60);
	}
	moveRobot(0,0);
	Err = 0;
	clearTimer(T1);
	while(time1(T1) < 1000)
	{
		Err = SensorValue[myGyro] + 900;
		moveRobot(-0.3*Err,0.3*Err);
	}
	moveRobot(0,0);
	Err = 0;
	nMotorEncoder[frontRight2] = 0;
	while(SensorValue[frontLim] > thresh)
	{
		Err = SensorValue[myGyro] + 900;
		moveRobot(50 - 0.3*Err,50 + 0.3*Err);
		if(nMotorEncoder[frontRight2] > 600)
		{
			break;
		}
	}
	clearTimer(T1);
	while(time1(T1)<100)
	{
		moveRobot(-60,-60);
	}
	moveRobot(0,0);
	clearTimer(T1);
	while(time1(T1) < 1500)
	{
		turnRollerToEat();
		moveClawsTo(1000);
	}
	moveClawsWith(0);
	motorReq[rollerMotor] = 0;
	clearTimer(T1);
	while(time1(T1)<1000)
	{
		motorReq[rollerMotor] = 30;
		if(SensorValue[clawsPot] < 2300){moveClawsTo(3300);motorReq[rollerMotor] = 30;}
		else{moveClawsWith(0);}
	}
	Err = 0;
	clearTimer(T1);
	while(time1(T1) < 1000)
	{
		if(time1(T1) < 800)
		{
			motorReq[MobGoalntake] = -127;
		}
		else
		{
			motorReq[MobGoalntake] = 0;
		}
		Err = SensorValue[myGyro] + 1050;
		moveRobot(-0.2*Err,+0.2*Err);
	}
	moveRobot(0,0);
	nMotorEncoder[frontRight2] = 0;
	while(nMotorEncoder[frontRight2] < 1300)
	{
		Err = SensorValue[myGyro] + 1050;
		moveRobot(60 - 0.3*Err,60 + 0.3*Err);
	}
	moveRobot(0,0);
	clearTimer(T1);
	while(time1(T1) < 1000)
	{
		motorReq[MobGoalntake] = 127;
	}
	motorReq[MobGoalntake] = 0;
	clearTimer(T1);
	while(time1(T1) < 500)
	{
		turnRollerToEject();
	}
	motorReq[rollerMotor] = 0;
	nMotorEncoder[frontRight2] = 0;
	while(nMotorEncoder[frontRight2] > -1500)
	{
		Err = SensorValue[myGyro] + 1050;
		moveRobot(-60 - 0.3*Err,-60 + 0.3*Err);
	}
	moveRobot(0,0);
	Err = 0;
	moveRobot(0,0);
	Err = 0;
	nMotorEncoder[frontRight2] = 0;
	clearTimer(T1);
	while(SensorValue[backLim] > 1800 || abs(nMotorEncoder[frontRight2]) < 400)
	{
		Err = SensorValue[myGyro] + 900;
		moveRobot(-60 - 0.3*Err,-60 + 0.3*Err);
		if(abs(nMotorEncoder[frontRight2]) > 2200)
		{
			break;
		}
	}
	moveRobot(0,0);
	nMotorEncoder[frontRight2] = 0;
	clearTimer(T1);
	while(abs(nMotorEncoder[frontRight2]) < 1500 || time1(T1) < 1000)
	{
		Err = SensorValue[myGyro] + 1350;
		moveRobot(-60 - 0.3*Err,-60 + 0.3*Err);
	}
	moveRobot(0,0);
	while(SensorValue[myGyro] > -2050)
	{
		moveRobot(-60,60);
	}
	moveRobot(0,0);
	Err = 0;
	clearTimer(T1);
	while(time1(T1) < 800)
	{
		Err = SensorValue[myGyro] + 2250;
		moveRobot(-0.3*Err,0.3*Err);
	}
	moveRobot(0,0);
	nMotorEncoder[frontRight2] = 0;
	while(nMotorEncoder[frontRight2] < 500)
	{
		moveRobot(50,50);
		motorReq[MobGoalntake] = -127;
	}
	moveRobot(0,0);
	motorReq[MobGoalntake] = 0;
	nMotorEncoder[frontRight2] = 0;
	while(nMotorEncoder[frontRight2] > -500)
	{
		moveRobot(-50,-50);
	}
	moveRobot(0,0);


}





task usercontrol()
{
	// User control code here, inside the loop
	startTask(MotorSlewRateTask);
	while (true)
	{
		if(vexRT[Btn5D])
		{
			turnRollerToEject();
		}
		else
		{
			motorReq[rollerMotor] = 0;
		}
		if(vexRT[Btn6U] && !vexRT[Btn6D])
		{
			MobInUp = true;
			MobInDown = false;

		}
		if(vexRT[Btn6D] && !vexRT[Btn6U])
		{
			MobInUp = false;
			MobInDown = true;
		}
		if(!vexRT[Btn6D] && !vexRT[Btn6U])
		{
			MobInUp = false;
			MobInDown = false;
		}
		if(MobInUp && !MobInDown)
		{
			motorReq[MobGoalntake] = 127;
		}
		else if(!MobInUp && MobInDown)
		{
			motorReq[MobGoalntake] = -127;
		}
		else
		{
			motorReq[MobGoalntake] = 0;
		}
		int a = vexRT[Ch2];
		int b = vexRT[Ch3];
		if(abs(a) < 15){a = 0;}
		if(abs(b) < 15){b = 0;}
		if(a*b < 0){a = 3*a/5;b = 3*b/5;}
		moveRobot(a,b);
	}
}


void moveClawsTo(int clawsTar)
{
	int Err = SensorValue[clawsPot] - clawsTar;
	moveClawsWith(0.1*Err);
}
void moveClawsWith(int speed)
{
	motorReq[rightClaws] = motorReq[leftClaws] = speed;
}
void moveCraneWith(int speed)
{
	motorReq[craneMotorsExp]= speed;
}
void moveCraneTo(int craneTar)
{
	int Err = -SensorValue[craneEnc] + craneTar;
	moveCraneWith(1.2*Err);
}
void moveRobot(int RSpeed, int LSpeed)
{
	motorReq[frontLeftExp] = LSpeed;
	motorReq[backLeft] = LSpeed;
	motorReq[frontRight1] = RSpeed;
	motorReq[frontRight2] = RSpeed;
	motorReq[backRight] = RSpeed;
}
void turnRollerToEat()
{
	motorReq[rollerMotor] = 127;
}
void turnRollerToEject()
{
	motorReq[rollerMotor] = -127;
}
