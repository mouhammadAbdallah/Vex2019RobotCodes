#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    myGyro,         sensorGyro)
#pragma config(Sensor, in2,    clawsPot,       sensorPotentiometer)
#pragma config(Sensor, in3,    backLim,        sensorLineFollower)
#pragma config(Sensor, in4,    frontLim,       sensorLineFollower)
#pragma config(Sensor, in5,    frontLim2,      sensorLineFollower)
#pragma config(Sensor, dgtl1,  craneEnc,       sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  RightBump,      sensorTouch)
#pragma config(Sensor, dgtl4,  LeftBump,       sensorTouch)
#pragma config(Sensor, dgtl5,  AdjtSwitch,     sensorTouch)
#pragma config(Sensor, dgtl6,  RorB,           sensorTouch)
#pragma config(Sensor, dgtl7,  AdjtSwitch2,    sensorTouch)
#pragma config(Sensor, dgtl8,  leftEnc,        sensorQuadEncoder)
#pragma config(Sensor, dgtl12, emergAut,       sensorTouch)
#pragma config(Sensor, I2C_1,  enc1,           sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           MobGoalntake,  tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           frontRight1,   tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           frontLeftExp,  tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port4,           rightClaws,    tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           backRight,     tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           backLeft,      tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port7,           leftClaws,     tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port8,           craneMotorsExp, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           frontRight2,   tmotorVex393HighSpeed_MC29, openLoop, reversed, encoderPort, I2C_1)
#pragma config(Motor,  port10,          rollerMotor,   tmotorVex393_HBridge, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX2)
#pragma competitionControl(Competition)

#include "Vex_Competition_Includes.c"
#define MOTOR_NUM               kNumbOfTotalMotors
#define MOTOR_MAX_VALUE         127
#define MOTOR_MIN_VALUE         (-127)
#define MOTOR_DEFAULT_SLEW_RATE 30      // Default will cause 375mS from full fwd to rev
#define MOTOR_FAST_SLEW_RATE    256     // essentially off
#define MOTOR_TASK_DELAY        20      // task 1/frequency in mS (about 66Hz)
#define MOTOR_DEADBAND          10
#define MAX_CMD									127

void moveClawsTo(int clawsTar);
void moveClawsWith(int speed);
void moveCraneWith(int speed);
void moveCraneTo(int craneTar);
void moveRobot(int RSpeed, int LSpeed);
void turnRollerToEject();
void turnRollerToEat();

int motorReq[MOTOR_NUM];
int motorSlew[MOTOR_NUM];

//Variables :
bool Blue = false;
bool holdStack = false;
bool holdStackClicked = false;
int Err = 0;
int Errd = 0;
int IErr = 0;
int IErrd = 0;
int IErrc = 0;
int Errc = 0;

int craneVals[10] = {0,0,40,80,110,150,200,250,290,320};
int craneValsH[10] = {0,75,105,150,200,250,300,350,400,450};
int craneValsHFeeder[10] = {60,70,100,160,220,250,290,320,370,440};
int craneValsStat[5] = {200,240,290,340,390};
int craneValsStatH[5] = {300,350,380,440,480};

bool statGoalMode = false;
bool goOnStat = false;
bool postfield = false;
bool prefield = false;
bool fieldMode = false;
bool goOnField = false;
bool goOnFeeder = false;
bool clawsRecv= false;
bool prefeeder = false;
bool feederMode = false;
bool MobInDown = false;
bool MobInUp = false;
int conesCount = 0;
int statCount = 0;

int test1 = 0;
int test2 = 0;
int test3 = 0;

task MotorSlewRateTask()
{
	int motorIndex;
	int motorTmp;


	// Initialize stuff
	for (motorIndex = 0; motorIndex < (signed)MOTOR_NUM; motorIndex++)
	{
		motorReq[motorIndex] = 0;
		motorSlew[motorIndex] = MOTOR_DEFAULT_SLEW_RATE;
	}

	// run task until stopped
	while (true)
	{
		// run loop for every motor
		for (motorIndex = 0; motorIndex < (signed)MOTOR_NUM; motorIndex++)
		{
			// So we don't keep accessing the internal storage
			motorTmp = motor[motorIndex];

			// Do we need to change the motor value ?
			if (motorTmp != motorReq[motorIndex])
			{
				// increasing motor value
				if (motorReq[motorIndex] > motorTmp)
				{
					motorTmp += motorSlew[motorIndex];
					// limit
					if (motorTmp > motorReq[motorIndex])
						motorTmp = motorReq[motorIndex];
				}

				// decreasing motor value
				if (motorReq[motorIndex] < motorTmp)
				{
					motorTmp -= motorSlew[motorIndex];
					// limit
					if (motorTmp < motorReq[motorIndex])
						motorTmp = motorReq[motorIndex];
				}

				// finally set motor
				motor[motorIndex] = motorTmp;
			}
		}

		// Wait approx the speed of motor update over the spi bus
		wait1Msec(MOTOR_TASK_DELAY);
	}
}

void pre_auton()
{
	bStopTasksBetweenModes = true;
	SensorValue[craneEnc] = 0;
	SensorValue[myGyro] = 0;
	nMotorEncoder[frontRight2] = 0;
}


task autonomous()
{
	startTask(MotorSlewRateTask);
	SensorValue[myGyro]= 0;
	if(SensorValue[emergAut] == 1)
	{
		//emergency autonomous
		nMotorEncoder[frontRight2] = 0;
		while(SensorValue[craneEnc] < 250)
		{
			moveCraneTo(300);
		}
		nMotorEncoder[frontRight2] = 0;
		while(nMotorEncoder[frontRight2]<200)
		{
			Err = SensorValue[myGyro];
			moveRobot(50 - 0.5*Err,50 + 0.5*Err);
			moveClawsTo(2300);
			moveCraneTo(300);
		}
		moveRobot(0,0);
		clearTimer(T1);
		while(time1(T1) < 1000)
		{
			moveClawsTo(2300);
			moveCraneTo(200);
		}
		clearTimer(T2);
		while(time1(T2) < 500)
		{
			turnRollerToEject();
			moveClawsTo(2300);
			moveCraneTo(200);
		}

		clearTimer(T1);
		while(time1(T1) < 1000)
		{
			moveClawsTo(2300);
			moveCraneTo(300);
		}
		motorReq[rollerMotor] = 0;
		clearTimer(T2);
		while(time1(T1) < 1000)
		{
			if(SensorValue[clawsPot] < 2600){moveClawsTo(3300);}
			else
			{
				moveClawsWith(0);
			}
			moveCraneTo(300);
		}
		while(time1(T1) < 1000)
		{
			if(SensorValue[craneEnc] > 10)
			{
				moveCraneWith(-127);
			}
			else
			{
				moveCraneWith(0);
			}
		}
		moveCraneWith(0);
		while(true);

	}

	if(SensorValue[RorB] == 0)
	{
		Blue = true;
	}
	else
	{
		Blue = false;
	}
	nMotorEncoder[frontRight2] = 0;
	Err = 0;
	//move Robot to Goal 1
	clearTimer(T1);
	IErr = 0;
	while(nMotorEncoder[frontRight2] < 1100 || SensorValue[backLim] > 1700)
	{
		Err = SensorValue[myGyro];
		IErr = IErr + Err;
		moveRobot(60 - 0.6*Err - 0.0001*IErr,60 + 0.6*Err + 0.0001*IErr);
		if(time1(T1) < 900)
		{
			motorReq[MobGoalntake] = -127;
		}
		else
		{
			motorReq[MobGoalntake] = 0;
		}
		if(time1(T1) > 5000)
		{
			while(true)
			{
				moveRobot(0,0);
			}
		}
	}
	moveRobot(0,0);
	clearTimer(T2);
	while(time1(T2)<100)
	{
		moveRobot(-50,-50);
	}
	moveRobot(0,0);
	nMotorEncoder[frontRight2] = 0;
	SensorValue[leftEnc] = 0;
	IErr = 0;
	if(Blue)
	{
		while(nMotorEncoder[frontRight2] < 150)
		{
			IErr = IErr + Err;
			Err = SensorValue[myGyro];
			moveRobot(40 - 0.8*Err - 0.0003*IErr,40 + 0.8*Err + 0.0003*IErr);
		}
	}
	else
	{
		while(SensorValue[leftEnc] < 150)
		{
			IErr = IErr + Err;
			Err = SensorValue[myGyro];
			moveRobot(40 - 0.8*Err - 0.0003*IErr,40 + 0.8*Err + 0.0003*IErr);
		}
	}
	moveRobot(0,0);
	//put goal on robot
	IErr = 0;
	clearTimer(T1);
	while(time1(T1)<1250)
	{
		IErr = IErr + Err;
		motorReq[MobGoalntake] = 127;
		Err = SensorValue[myGyro];
		moveRobot(-0.6*Err,0.6*Err);
	}
	moveRobot(0,0);
	motorReq[MobGoalntake] = 0;
	clearTimer(T1);
	while(time1(T1)<500)
	{
		turnRollerToEject();
	}
	//cone scored
	motorReq[rollerMotor] = 0;
	nMotorEncoder[frontRight2] = 0;
	SensorValue[leftEnc] = 0;
	//go to the second cone
	//claws Down
	clearTimer(T2);
	while(time1(T2) < 1000)
	{
		moveClawsTo(1800);
	}
	IErr = 0;
	if(Blue)
	{
		while(nMotorEncoder[frontRight2] < 100)
		{
			moveClawsTo(1800);
			Err = SensorValue[myGyro] - 50;

			IErr = IErr + Err;
			moveRobot(60 - 0.5*Err - 0.0001*IErr,30 + 0.5*Err+0.0001*IErr);
			//moveRobot(60,0);

		}
	}
	else
	{
		while(SensorValue[leftEnc] < 80)
		{
			moveClawsTo(1800);
			Err = SensorValue[myGyro] + 40;

			IErr = IErr + Err;
			moveRobot(30 - 0.5*Err - 0.0001*IErr,60 + 0.5*Err+0.0001*IErr);
			//moveRobot(60,0);

		}
	}
	moveRobot(0,0);
	//eat second cone
	clearTimer(T1);
	while(time1(T1) < 800)
	{
		moveClawsTo(1000);
		turnRollerToEat();
		//	Err = SensorValue[myGyro];
		//moveRobot(-0.6*Err,0.6*Err);
	}
	motorReq[rollerMotor] = 30;
	moveClawsWith(0);
	moveRobot(0,0);
	clearTimer(T2);
	while(time1(T2) < 1000)
	{
		//Err = SensorValue[myGyro];
		//moveRobot(-0.6*Err,0.6*Err);
		moveCraneTo(40);
		if(SensorValue[clawsPot] < 2500)
		{
			moveClawsTo(3300);
		}
		else
		{
			moveClawsWith(0);
		}
	}
	clearTimer(T2);
	while(time1(T2) < 500)
	{
		turnRollerToEject();
	}
	//second cone scored , going for the third
	motorReq[rollerMotor] = 0;
	clearTimer(T2);
	while(time1(T2) < 800)
	{
		moveClawsTo(1800);
		Err = SensorValue[myGyro];
		//moveRobot(-0.6*Err,0.6*Err);
	}
	clearTimer(T2);
	//while(time1(T2) < 800)
	//{
	//	Err = SensorValue[myGyro];
	//	//moveRobot(-0.6*Err,0.6*Err);
	//	moveClawsTo(1800);
	//	if(SensorValue[craneEnc] > 10)
	//	{
	//		moveCraneTo(0);
	//	}
	//	else
	//	{
	//		moveCraneWith(0);
	//	}
	//}
	nMotorEncoder[frontRight2] = 0;
	SensorValue[leftEnc] = 0;
	IErr = 0;
	//moving to the third
	if(Blue){
		clearTimer(T1);
		while(nMotorEncoder[frontRight2] < 220)
		{
			//moveClawsTo(1800);
			if(SensorValue[craneEnc] > 10)
			{
				moveCraneTo(0);
			}
			else
			{
				moveCraneWith(0);
			}
			moveClawsTo(1800);
			Err = SensorValue[myGyro] - 50;

			IErr = IErr + Err;
			moveRobot(50 - 0.4*Err - 0.000*IErr,50 + 0.4*Err+0.000*IErr);
			if(time1(T1) > 1000)
			{
				break;
			}
		}
	}
	else
	{
		clearTimer(T1);
		while(SensorValue[leftEnc] < 220)
		{
			if(SensorValue[craneEnc] > 10)
			{
				moveCraneTo(0);
			}
			else
			{
				moveCraneWith(0);
			}
			moveClawsTo(1800);
			Err = SensorValue[myGyro] + 40;

			IErr = IErr + Err;
			moveRobot(50 - 0.4*Err - 0.000*IErr,50 + 0.4*Err+0.000*IErr);
			if(time1(T1) > 1000)
			{
				break;
			}
		}
	}
	moveRobot(0,0);
	clearTimer(T1);
	while(time1(T1) < 800)
	{
		moveClawsTo(1000);
		turnRollerToEat();
		//Err = SensorValue[myGyro];
		//moveRobot(-0.6*Err,0.6*Err);
	}
	motorReq[rollerMotor] = 30;
	moveClawsWith(0);
	moveRobot(0,0);
	IErr = 0;
	//clearTimer(T2);
	//while(time1(T2) < 1200)
	//{
	//	Err = SensorValue[myGyro];
	//	//moveRobot(-0.6*Err,0.6*Err);
	//	moveCraneTo(100);
	//	if(time1(T2) > 500)
	//	{
	//		if(SensorValue[clawsPot] < 2500)
	//		{
	//			moveClawsTo(3300);
	//		}
	//		else
	//		{
	//			moveClawsWith(0);
	//		}
	//	}
	//}
	//clearTimer(T1);
	//while(time1(T1) < 500)
	//{
	//	turnRollerToEject();
	//}
	//third cone scored
	motorReq[rollerMotor] = 30;
	nMotorEncoder[frontRight2] = 0;
	IErrd = 0;
	IErr = 0;
	IErrc = 0;
	if(Blue)
	{
		clearTimer(T2);
		while(abs(nMotorEncoder[frontRight2]) < 1100 || SensorValue[backLim] > 1700)
		{
			if(time1(T2) < 1200)
			{
				moveCraneTo(100);
				if(time1(T2) > 500)
				{
					if(SensorValue[clawsPot] < 2500)
					{
						moveClawsTo(3300);
					}
					else
					{
						moveClawsWith(0);
					}
				}
			}
			if(time1(T2) > 1400)
			{
				turnRollerToEject();
			}
			Errd = SensorValue[myGyro] + 10;
			IErrd = IErrd + Errd;
			moveRobot(-80 - 1*Errd - 0.0001*IErrd,-80 + 1*Errd + 0.0001*IErrd);

			moveCraneTo(100);
		}
	}
	else
	{
		clearTimer(T2);
		while(abs(nMotorEncoder[frontRight2]) < 1100 || SensorValue[backLim] > 1700)
		{
			if(time1(T2) < 1200)
			{
				moveCraneTo(100);
				if(time1(T2) > 500)
				{
					if(SensorValue[clawsPot] < 2500)
					{
						moveClawsTo(3300);
					}
					else
					{
						moveClawsWith(0);
					}
				}
			}
			if(time1(T2) > 1400)
			{
				turnRollerToEject();
			}
			Errd = SensorValue[myGyro] - 10;
			IErrd = IErrd + Errd;
			moveRobot(-80 - 1*Errd - 0.0001*IErrd,-80 + 1*Errd + 0.0001*IErrd);

			moveCraneTo(100);
		}
	}
	moveRobot(0,0);
	motorReq[rollerMotor] = 0;
	clearTimer(T1);
	while(time1(T1) < 150)
	{
		moveRobot(-60,-60);
	}
	moveRobot(0,0);
	if(Blue)
	{
		while(SensorValue[myGyro] < 300)
		{
			moveRobot(60,-60);
		}
		moveRobot(0,0);
		clearTimer(T1);
		while(time1(T1) < 800)
		{
			Err = SensorValue[myGyro] - 450;
			moveRobot(-0.3*Err,0.3*Err);
		}

		moveRobot(0,0);
		nMotorEncoder[frontRight2] = 0;
		clearTimer(T1);
		while(nMotorEncoder[frontRight2] > -700 || time1(T1) < 200)
		{
			moveCraneTo(100);
			Err = SensorValue[myGyro] - 450;
			moveRobot(-60 - 0.8*Err,-60 + 0.8*Err);
		}
		moveRobot(0,0);
		//turn 2 : going to score
		while(SensorValue[myGyro] < 1200)
		{
			moveRobot(60,-60);
		}
		moveRobot(0,0);
		clearTimer(T1);
		while(time1(T1)<1000)
		{
			Err = SensorValue[myGyro] - 1350;
			moveRobot(-0.4*Err,0.4*Err);
		}
	}
	else
	{
		while(SensorValue[myGyro] > -300)
		{
			moveRobot(-60,60);
		}
		moveRobot(0,0);
		clearTimer(T1);
		while(time1(T1) < 800)
		{
			Err = SensorValue[myGyro] + 450;
			moveRobot(-0.3*Err,0.3*Err);
		}
		moveRobot(0,0);
		nMotorEncoder[frontRight2] = 0;
		clearTimer(T1);
		while(nMotorEncoder[frontRight2] > -600 || time1(T1) < 400)
		{
			moveCraneTo(100);
			Err = SensorValue[myGyro] + 450;
			moveRobot(-60 - 0.8*Err,-60 + 0.8*Err);
		}
		moveRobot(0,0);
		//turn 2 : going to score
		while(SensorValue[myGyro] > -1200)
		{
			moveRobot(-60,60);
		}
		moveRobot(0,0);
		clearTimer(T1);
		while(time1(T1)<1000)
		{
			Err = SensorValue[myGyro] + 1350;
			moveRobot(-0.4*Err,0.4*Err);
		}
	}
	clearTimer(T1);
	while(time1(T1) < 1200)
	{
		moveRobot(55,55);
		if(time1(T1) > 400)
		{
			motorReq[MobGoalntake] = -127;
		}
	}
	motorReq[MobGoalntake]  = 30;
	moveRobot(0,0);
	clearTimer(T1);
	while(time1(T1) < 500)
	{
		moveRobot(0,0);
	}
	moveRobot(0,0);
	moveCraneWith(0);
	clearTimer(T1);
	while(time1(T1) < 100)
	{
		moveRobot(-127,-127);
	}
	moveRobot(0,0);
	//clearTimer(T1);
	//while(time1(T1) < 400)
	//{
	//	moveRobot(70,70);
	//}
	//moveRobot(0,0);
	//clearTimer(T1);
	//while(time1(T1) < 300)
	//{
	//	moveRobot(-70,-70);
	//}
	//moveRobot(0,0);
	clearTimer(T1);
	while(time1(T1) < 400)
	{
		moveRobot(127,127);
	}
	moveRobot(0,0);
	nMotorEncoder[frontRight2] = 0;
	clearTimer(T1);
	while(time1(T1) < 600)
	{
		motorReq[MobGoalntake] = 127;
	}
	motorReq[MobGoalntake] = 0;

	while(abs(nMotorEncoder[frontRight2]) < 500)
	{
		moveCraneTo(0);
		if(abs(nMotorEncoder[frontRight2])> 100)
		{
			motorReq[MobGoalntake] = -127;
		}
		else
		{
			motorReq[MobGoalntake] = 0;
		}
		moveRobot(-50,-50);
	}
	moveRobot(0,0);
	clearTimer(T1);
	while(time1(T1) < 100)
	{
		moveRobot(50,50);
	}
	moveRobot(0,0);
	clearTimer(T1);
	while(time1(T1) < 500)
	{
		motorReq[MobGoalntake] = 127;
	}
	motorReq[MobGoalntake] = 0;
	SensorValue[myGyro] = 0;

	if(Blue)
	{
		while(SensorValue[myGyro] > -600)
		{
			moveRobot(-50,50);
		}
		moveRobot(0,0);
		while(SensorValue[AdjtSwitch] == 0)
		{
			Err = SensorValue[myGyro] + 900;
			moveRobot(-40 - 0.3*Err, -40 + 0.3*Err);
		}
		moveRobot(0,0);
		clearTimer(T1);
		while(time1(T1) < 200)
		{
			moveRobot(50,50);
		}
		moveRobot(0,0);
		while(SensorValue[myGyro] > -1250)
		{
			moveRobot(-70,0);
		}
		moveRobot(0,0);
		clearTimer(T1);
		clearTimer(T2);
		while(true)
		{
			moveRobot(-40,-40);
			if(time1(T1) > 250 || time1(T2) > 250 || (SensorValue[LeftBump] == 1 && SensorValue[RightBump] == 1))
			{
				break;
			}
		}
	}
	else
	{
		while(SensorValue[myGyro] < 600)
		{
			moveRobot(60,-60);
		}
		moveRobot(0,0);
		while(SensorValue[AdjtSwitch2] == 0)
		{
			Err = SensorValue[myGyro] - 900;
			moveRobot(-40 - 0.3*Err, -40 + 0.3*Err);
		}
		moveRobot(0,0);
		clearTimer(T1);
		while(time1(T1) < 100)
		{
			moveRobot(50,50);
		}
		moveRobot(0,0);
		while(SensorValue[myGyro] < 1350)
		{
			moveRobot(0,-70);
		}
		moveRobot(0,0);
		clearTimer(T2);
		clearTimer(T1);
		while(true)
		{
			moveRobot(-40,-40);
			if(time1(T2) > 250 || time1(T1) > 250 || (SensorValue[LeftBump] == 1 && SensorValue[RightBump] == 1))
			{
				break;
			}
		}
	}

	moveRobot(0,0);
	SensorValue[myGyro] = 0;
	nMotorEncoder[frontRight2] = 0;
	while(nMotorEncoder[frontRight2] < 380)
	{
		moveRobot(50,50);
	}
	moveRobot(0,0);
	clearTimer(T2);
	while(time1(T2) < 100)
	{
		moveRobot(-50,-50);
	}
	moveRobot(0,0);
	clearTimer(T1);
	//while(time1(T1) < 800)
	//{
	//	moveCraneTo(0);
	//}
	moveCraneWith(0);
	if(Blue)
	{
		while(SensorValue[myGyro] > -600)
		{
			moveRobot(-60,60);
		}
		moveRobot(0,0);
		Err = 0;
		clearTimer(T1);
		while(time1(T1) < 1000)
		{
			Err = SensorValue[myGyro] + 900;
			moveRobot(-0.3*Err,0.3*Err);
		}
		moveRobot(0,0);
		Err = 0;
		nMotorEncoder[frontRight2] = 0;
		while(nMotorEncoder[frontRight2] < 800 && SensorValue[frontLim] > 1700)
		{
			Err = SensorValue[myGyro] + 900;
			moveRobot(50 - 0.5*Err,50 + 0.5*Err);
		}
	}
	else
	{
		while(SensorValue[myGyro] < 600)
		{
			moveRobot(60,-60);
		}
		moveRobot(0,0);
		Err = 0;
		clearTimer(T1);
		while(time1(T1) < 1000)
		{
			Err = SensorValue[myGyro] - 900;
			moveRobot(-0.3*Err,0.3*Err);
		}
		moveRobot(0,0);
		Err = 0;
		nMotorEncoder[frontRight2] = 0;
		while(nMotorEncoder[frontRight2] < 800 && SensorValue[frontLim2] > 1700)
		{
			Err = SensorValue[myGyro] - 900;
			moveRobot(50 - 0.5*Err,50 + 0.5*Err);
		}
	}
	moveRobot(0,0);
	clearTimer(T2);
	while(time1(T2) < 100)
	{
		moveRobot(-50,-50);
	}
	moveRobot(0,0);

	clearTimer(T1);
	while(time1(T1) < 1000)
	{
		if(time1(T1) < 700)
		{
			motorReq[MobGoalntake] = -127;
		}
		turnRollerToEat();
		moveClawsTo(1000);
	}
	moveClawsWith(0);
	motorReq[rollerMotor] = 30;
	motorReq[MobGoalntake] = 0;
	//clearTimer(T1);
	//while(time1(T1)<1000)
	//{
	//	motorReq[rollerMotor] = 30;
	//	if(SensorValue[clawsPot] < 2300){moveClawsTo(3300);motorReq[rollerMotor] = 30;}
	//	else{moveClawsWith(0);}
	//}
	Err = 0;
	if(Blue)
	{
		clearTimer(T1);
		while(time1(T1) < 1000)
		{
			//if(time1(T1) < 300)
			//{
			//	motorReq[MobGoalntake] = -127;
			//}
			//else
			//{
			//	motorReq[MobGoalntake] = 0;
			//}

			if(SensorValue[clawsPot] < 2500)
			{
				moveClawsTo(3300);
			}
			else
			{
				moveClawsWith(0);
			}
			Err = SensorValue[myGyro] + 1200;
			moveRobot(-0.5*Err,+0.5*Err);
		}
		moveRobot(0,0);
		nMotorEncoder[frontRight2] = 0;
		while(nMotorEncoder[frontRight2] < 800)
		{
			motorReq[rollerMotor] = 50;
			motorReq[MobGoalntake] = -30;
			Err = SensorValue[myGyro] + 1200;
			moveRobot(50 - 0.5*Err,50 + 0.5*Err);
		}
	}
	else
	{
		clearTimer(T1);
		while(time1(T1) < 1000)
		{
			motorReq[rollerMotor] = 30;
			if(SensorValue[clawsPot] < 2300){moveClawsTo(3300);motorReq[rollerMotor] = 30;}
			else{moveClawsWith(0);}

			if(time1(T1) < 500)
			{
				motorReq[MobGoalntake] = -127;
			}
			else
			{
				motorReq[MobGoalntake] = 0;
			}
			Err = SensorValue[myGyro] - 1200;
			moveRobot(-0.5*Err,+0.5*Err);
		}
		moveRobot(0,0);
		nMotorEncoder[frontRight2] = 0;
		while(nMotorEncoder[frontRight2] < 800)
		{
			motorReq[MobGoalntake] = -30;
			Err = SensorValue[myGyro] - 1200;
			moveRobot(50 - 0.5*Err,50 + 0.5*Err);
		}
	}
	motorReq[MobGoalntake] = 0;
	moveRobot(0,0);
	clearTimer(T1);
	while(time1(T1) < 1500)
	{
		if(time1(T1)<200)
		{
			turnRollerToEat();
		}
		else
		{
			motorReq[rollerMotor] = 30;
		}
		motorReq[MobGoalntake] = 127;
	}
	motorReq[MobGoalntake] = 0;
	clearTimer(T1);
	while(time1(T1) < 500)
	{
		turnRollerToEject();
	}
	motorReq[rollerMotor] = 0;
	IErr = 0;
	if(Blue)
	{
		clearTimer(T1);
		while(time1(T1) < 1000)
		{
			Err = SensorValue[myGyro] + 950;
			IErr = IErr + Err;
			moveRobot(-0.3*Err, 0.3*Err);
		}
		moveRobot(0,0);
		SensorValue[leftEnc] = 0;
		while(SensorValue[leftEnc] < 20)
		{
			moveClawsTo(1800);
			Err = SensorValue[myGyro] + 1000;
			IErr = IErr + Err;
			moveRobot(40 - 0.3*Err,60 + 0.3*Err);
			//moveRobot(60,0);
		}
	}
	else
	{
		clearTimer(T1);
		while(time1(T1) < 1000)
		{
			Err = SensorValue[myGyro] - 950;
			IErr = IErr + Err;
			moveRobot(-0.3*Err, 0.3*Err);
		}
		moveRobot(0,0);
		nMotorEncoder[frontRight2] = 0;
		while(nMotorEncoder[frontRight2] < 20)
		{
			moveClawsTo(1800);
			Err = SensorValue[myGyro] - 1000;
			IErr = IErr + Err;
			moveRobot(60 - 0.3*Err,40 + 0.3*Err);
			//moveRobot(60,0);
		}
	}
	moveRobot(0,0);
	//eat second cone
	clearTimer(T1);
	while(time1(T1) < 1000)
	{
		moveClawsTo(1000);
		turnRollerToEat();
	}
	motorReq[rollerMotor] = 30;
	moveClawsWith(0);
	moveRobot(0,0);
	IErrc = 0;
	clearTimer(T2);
	while(time1(T2) < 1000)
	{
		moveCraneTo(40);
		if(SensorValue[clawsPot] < 2500)
		{
			moveClawsTo(3300);
		}
		else
		{
			moveClawsWith(0);
		}
	}
	clearTimer(T2);
	while(time1(T2) < 500)
	{
		turnRollerToEject();
	}
	if(Blue)
	{
		SensorValue[leftEnc] = 0;
		while(SensorValue[leftEnc] < 150)
		{
			if(SensorValue[leftEnc] > 100){
				moveClawsTo(1800);
			}
			Err = SensorValue[myGyro] + 1100;
			IErr = IErr + Err;
			moveRobot(60 - 0.5*Err - 0.0001*IErr,30 + 0.5*Err+0.0001*IErr);
			//moveRobot(60,0);
			if(SensorValue[craneEnc] > 10)
			{
				moveCraneWith(-127);
			}
			else
			{
				moveCraneWith(0);
			}
		}
		moveRobot(0,0);
		clearTimer(T2);
		while(time1(T2) < 1000)
		{
			if(SensorValue[craneEnc] > 10)
			{
				moveCraneWith(-127);
			}
			else
			{
				moveCraneWith(0);
			}
			//moveCraneTo(0);
			moveClawsTo(1000);
			turnRollerToEat();
		}
		motorReq[rollerMotor] = 30;
	}
	else
	{
		nMotorEncoder[frontRight2] = 0;
		while(nMotorEncoder[frontRight2] < 180)
		{
			if(nMotorEncoder[frontRight2] > 100){
				moveClawsTo(1800);
			}
			Err = SensorValue[myGyro] - 1100;
			IErr = IErr + Err;
			moveRobot(60 - 0.5*Err - 0.0001*IErr,30 + 0.5*Err+0.0001*IErr);
			//moveRobot(60,0);
			moveClawsTo(1800);
			if(SensorValue[craneEnc] > 10)
			{
				moveCraneWith(-127);
			}
			else
			{
				moveCraneWith(0);
			}

		}
		moveRobot(0,0);
		clearTimer(T2);
		while(time1(T2) < 1000)
		{
			moveCraneTo(0);
			turnRollerToEat();
		}
		motorReq[rollerMotor] = 30;
	}
	//second cone scored , going for the third
	if(Blue)
	{
		nMotorEncoder[frontRight2] = 0;
		clearTimer(T1);
		while(nMotorEncoder[frontRight2] > -1500)
		{
			Err = SensorValue[myGyro] + 1100;
			moveRobot(-50 - 0.3*Err,-50 + 0.3*Err);
			moveCraneTo(100);
			if(SensorValue[clawsPot] < 2500)
			{
				moveClawsTo(3300);
			}
			else
			{
				moveClawsWith(0);
			}
		}
		moveRobot(0,0);
		Err = 0;
		IErrc = 0;
		nMotorEncoder[frontRight2] = 0;
		while(SensorValue[backLim] > 1800)
		{
			turnRollerToEject();
			Err = SensorValue[myGyro] + 900;
			moveRobot(-50 - 0.3*Err,-50 + 0.3*Err);
		}
		moveRobot(0,0);
		clearTimer(T1);
		while(time1(T1) < 1000)
		{
			Err = SensorValue[myGyro] + 2250;
			moveRobot(-0.3*Err,0.3*Err);
		}
		moveRobot(0,0);
		clearTimer(T1);
		while(time1(T1)< 600)
		{
			motorReq[MobGoalntake] = -127;
			moveRobot(50,50);
		}
		motorReq[MobGoalntake] = 0;
		moveRobot(-50,-50);
	}
	else
	{
		nMotorEncoder[frontRight2] = 0;
		clearTimer(T1);
		while(nMotorEncoder[frontRight2] > -1500)
		{
			moveCraneTo(100);
			if(SensorValue[clawsPot] < 2500)
			{
				moveClawsTo(3300);
			}
			else
			{
				moveClawsWith(0);
			}
			Err = SensorValue[myGyro] - 1100;
			moveRobot(-50 - 0.3*Err,-50 + 0.3*Err);
		}
		moveRobot(0,0);
		Err = 0;
		nMotorEncoder[frontRight2] = 0;
		while(SensorValue[backLim] > 1800)
		{
			turnRollerToEject();
			Err = SensorValue[myGyro] - 900;
			moveRobot(-50 - 0.3*Err,-50 + 0.3*Err);
		}
		moveRobot(0,0);
		clearTimer(T1);
		while(time1(T1) < 1000)
		{
			Err = SensorValue[myGyro] - 2250;
			moveRobot(-0.3*Err,0.3*Err);
		}
		moveRobot(0,0);
		clearTimer(T1);
		while(time1(T1)< 600)
		{
			motorReq[MobGoalntake] = -127;
			moveRobot(50,50);
		}
		motorReq[MobGoalntake] = 0;
		moveRobot(-50,-50);
	}
	clearTimer(T1);
	while(time1(T1)<500){}
	moveRobot(0,0);

}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////

task usercontrol()
{
	startTask(MotorSlewRateTask);
	SensorValue[craneEnc] = 0;
	SensorValue[myGyro] = 0;
	int c = 0;
	while (true)
	{
		test2 = SensorValue[craneEnc];
		while(vexRT[Btn6UXmtr2])
		{
			turnRollerToEat();
		}

		while(vexRT[Btn6DXmtr2])
		{
			turnRollerToEject();
		}

		motorReq[rollerMotor] = 0;
		if(vexRT[Btn8L] && vexRT[Btn8R])
		{
			conesCount = 0;
		}
		if(vexRT[Btn8RXmtr2])
		{
			postfield = false;
			holdStack = true;
			holdStackClicked = true;
		}
		if(vexRT[Btn7R] && !feederMode)
		{
			statGoalMode = true;
			goOnStat = true;
		}
		if(vexRT[Btn6U] && !vexRT[Btn6D])
		{
			MobInUp = true;
			MobInDown = false;

		}
		if(vexRT[Btn6D] && !vexRT[Btn6U])
		{
			MobInUp = false;
			MobInDown = true;
		}
		if(!vexRT[Btn6D] && !vexRT[Btn6U])
		{
			MobInUp = false;
			MobInDown = false;
		}
		if(MobInUp && !MobInDown)
		{
			motorReq[MobGoalntake] = 127;
		}
		else if(!MobInUp && MobInDown)
		{
			motorReq[MobGoalntake] = -127;
		}
		else
		{
			motorReq[MobGoalntake] = 0;
		}

		if(vexRT[Btn7UXmtr2] && !feederMode)
		{
			prefeeder = true;
			postfield = false;
			prefield = false;
		}
		if(vexRT[Btn8LXmtr2] && !fieldMode)
		{
			feederMode = false;
			prefeeder = false;
			fieldMode = false;
			clawsRecv = true;
		}

		if(vexRT[Btn8UXmtr2] && !fieldMode)
		{
			holdStack = false;
			prefeeder = false;
			prefield = false;
			postfield = true;
		}
		if(vexRT[Btn8DXmtr2] && !fieldMode)
		{
			prefeeder = false;
			prefield = true;
			postfield = false;
		}
		if(vexRT[Btn7U])
		{
			feederMode = true;
			goOnFeeder = true;
			fieldMode = false;
			goOnField = false;
			prefeeder = false;
			postfield = false;
			prefield = false;

		}
		if(vexRT[Btn7D])
		{
			feederMode = false;
			goOnFeeder = false;

		}
		if(vexRT[Btn8U])
		{
			fieldMode = true;
			goOnField = true;
			clawsRecv = false;
			feederMode = false;
			goOnFeeder = false;
			prefield = false;
			prefeeder = false;
			postfield = false;

		}
		if(vexRT[Btn8D])
		{
			fieldMode = false;
			goOnField = false;
		}
		if(clawsRecv && !fieldMode)
		{
			if(SensorValue[clawsPot] < 3300)
			{
				moveClawsTo(3300);
			}
			else
			{
				moveClawsWith(0);
				clawsRecv = false;
			}
		}
		if(holdStack)
		{
			if(SensorValue[craneEnc] > 200)
			{
				if(SensorValue[craneEnc] > craneVals[conesCount]){
					moveCraneTo(craneVals[conesCount]);
				}
				else
				{
					moveCraneWith(0);
				}
			}
		}
		if(prefeeder)
		{
			moveCraneTo(130);
			moveClawsTo(2000);
		}
		if(prefield)
		{
			if(SensorValue[craneEnc] > 20){
				moveCraneTo(0);
			}
			else
			{
				moveCraneWith(0);
			}
			if(SensorValue[clawsPot] < 2300){moveClawsTo(3300);}
			else{moveClawsWith(0);}
		}
		if(postfield)
		{

			if(holdStackClicked)
			{
				turnRollerToEject();
			}
			else
			{
				motorReq[rollerMotor] = 0;
			}

			moveCraneTo(450);
			if(SensorValue[craneEnc] < 350)
				moveClawsTo(1800);
			if(SensorValue[craneEnc] > 350){
				if(SensorValue[clawsPot] < 2400){moveClawsTo(3300);}
				else{moveClawsWith(0);}
			}
		}
		if(statGoalMode)
		{
			statGoalMode = false;
			int a1 = 0;
			int b1 = 0;
			while(!vexRT[Btn5DXmtr2] && goOnStat)
			{
				if(vexRT[Btn8D])
				{
					goOnStat = false;
				}
				moveClawsTo(1800);
				if(SensorValue[craneEnc] > 10)
				{
					moveCraneWith(-127);
				}
				else
				{
					moveCraneWith(0);
				}
				a1 = vexRT[Ch2];
				b1 = vexRT[Ch3];
				if(abs(a1) < 15){a1 = 0;}
				if(abs(b1) < 15){b1 = 0;}
				if(a1*b1 < 0){a1 = 3*a1/5;b1 = 3*b1/5;}
				moveRobot(a1,b1);
				delay(10);
			}
			while(!vexRT[Btn5UXmtr2] && goOnStat)
			{
				if(vexRT[Btn8D])
				{
					goOnStat = false;
				}
				moveClawsTo(1000);
				turnRollerToEat();
				if(SensorValue[craneEnc] > 5)
				{
					moveCraneWith(-127);
				}
				else
				{
					moveCraneWith(0);
				}
				a1 = vexRT[Ch2];
				b1 = vexRT[Ch3];
				if(abs(a1) < 15){a1 = 0;}
				if(abs(b1) < 15){b1 = 0;}
				if(a1*b1 < 0){a1 = 3*a1/5;b1 = 3*b1/5;}
				moveRobot(a1,b1);
				delay(10);
			}
			while(!vexRT[Btn5DXmtr2] && goOnStat)
			{
				if(vexRT[Btn8D])
				{
					goOnStat = false;
				}
				moveClawsTo(2400);
				motorReq[rollerMotor] = 30;
				moveCraneTo(craneValsStatH[statCount]);
				a1 = vexRT[Ch2];
				b1 = vexRT[Ch3];
				if(abs(a1) < 15){a1 = 0;}
				if(abs(b1) < 15){b1 = 0;}
				if(a1*b1 < 0){a1 = 3*a1/5;b1 = 3*b1/5;}
				moveRobot(a1,b1);
				delay(10);
			}
			while(!vexRT[Btn5UXmtr2] && goOnStat)
			{
				if(vexRT[Btn8D])
				{
					goOnStat = false;
				}
				moveClawsTo(2400);
				motorReq[rollerMotor] = 30;
				moveCraneTo(craneValsStat[statCount]);
				a1 = vexRT[Ch2];
				b1 = vexRT[Ch3];
				if(abs(a1) < 15){a1 = 0;}
				if(abs(b1) < 15){b1 = 0;}
				if(a1*b1 < 0){a1 = 3*a1/5;b1 = 3*b1/5;}
				moveRobot(a1,b1);
				delay(10);
			}
			clearTimer(T1);
			clearTimer(T2);
			while(!vexRT[Btn5DXmtr2] && goOnStat)
			{
				if(vexRT[Btn8D])
				{
					goOnStat = false;
				}
				moveClawsTo(2400);
				turnRollerToEject();
				if(time1(T2) < 500)
				{
					moveCraneTo(craneValsStat[statCount]);
				}
				else
				{
					moveCraneTo(craneValsStatH[statCount]);
				}
				a1 = vexRT[Ch2];
				b1 = vexRT[Ch3];
				if(abs(a1) < 15){a1 = 0;}
				if(abs(b1) < 15){b1 = 0;}
				if(a1*b1 < 0){a1 = 3*a1/5;b1 = 3*b1/5;}
				moveRobot(a1,b1);
				delay(10);
			}
			while(!vexRT[Btn5UXmtr2] && goOnStat)
			{
				if(vexRT[Btn8D])
				{
					goOnStat = false;
				}
				if(SensorValue[clawsPot] < 2700)
				{
					moveClawsTo(3300);
				}
				else
				{
					moveClawsWith(0);
					if(SensorValue[craneEnc] > 10)
					{
						moveCraneTo(0);
					}
					else
					{
						moveCraneWith(0);
					}
				}
				a1 = vexRT[Ch2];
				b1 = vexRT[Ch3];
				if(abs(a1) < 15){a1 = 0;}
				if(abs(b1) < 15){b1 = 0;}
				if(a1*b1 < 0){a1 = 3*a1/5;b1 = 3*b1/5;}
				moveRobot(a1,b1);
				delay(10);
			}

			while(true && goOnStat)
			{
				moveRobot(0,0);
				if(vexRT[Btn5U])
				{
					statCount = statCount + 1;
					break;
				}
				if(vexRT[Btn5D])
				{
					break;
				}

			}
			moveCraneWith(0);
		}
		moveRobot(0,0);
		if(fieldMode)
		{
			int a1 = 0;
			int b1 = 0;
			bool man_aut;
			//moving claws to mid position
			if(conesCount > 0){
				IErr = 0;
				while(!vexRT[Btn5DXmtr2] && goOnField)
				{
					if(vexRT[Btn8D])
					{
						goOnField = false;
						fieldMode = false;
					}
					moveClawsTo(1800);
					if(man_aut)
					{
						if(SensorValue[craneEnc] > 10)
						{moveCraneTo(0);}
						else
						{
							moveCraneWith(0);
						}
					}
					else
					{
						moveCraneWith(-127);
					}
					if(vexRT[Ch2Xmtr2] < -10)
					{
						man_aut = false;
					}
					else
					{
						man_aut = true;
					}
					a1 = vexRT[Ch2];
					b1 = vexRT[Ch3];
					if(abs(a1) < 15){a1 = 0;}
					if(abs(b1) < 15){b1 = 0;}
					if(a1*b1 < 0){a1 = 3*a1/5;b1 = 3*b1/5;}
					moveRobot(a1,b1);
					//CraneEncVal = SensorValue[CraneEnc];
					delay(10);
				}
				moveRobot(0,0);
				//claws down + Roller eating
				IErr = 0;
				while(!vexRT[Btn5UXmtr2] && goOnField)
				{
					if(vexRT[Btn8D])
					{
						goOnField = false;
						fieldMode = false;
					}
					moveClawsTo(1000);
					if(vexRT[Ch2Xmtr2] < -10)
					{
						man_aut = false;
					}
					else
					{
						man_aut = true;
					}
					if(man_aut)
					{
						if(SensorValue[craneEnc] > 10)
						{moveCraneTo(0);}
						else
						{
							moveCraneWith(0);
						}
					}
					else
					{
						moveCraneWith(-127);
					}
					turnRollerToEat();
					a1 = vexRT[Ch2];
					b1 = vexRT[Ch3];
					if(abs(a1) < 15){a1 = 0;}
					if(abs(b1) < 15){b1 = 0;}
					if(a1*b1 < 0){a1 = 3*a1/5;b1 = 3*b1/5;}
					moveRobot(a1,b1);
					delay(10);
				}
				//go back to mid position
				IErr = 0;
				while(!vexRT[Btn5DXmtr2] && goOnField)
				{
					if(vexRT[Btn8D])
					{
						goOnField = false;
						fieldMode = false;
					}
					motorReq[rollerMotor] = 30;
					moveClawsTo(1700);
					a1 = vexRT[Ch2];
					b1 = vexRT[Ch3];
					if(abs(a1) < 15){a1 = 0;}
					if(abs(b1) < 15){b1 = 0;}
					if(a1*b1 < 0){a1 = 3*a1/5;b1 = 3*b1/5;}
					moveRobot(a1,b1);

					delay(10);
				}
				//moving crane to desired position
				IErr = 0;
				while(!vexRT[Btn5UXmtr2] && goOnField)
				{
					if(vexRT[Btn8D])
					{
						goOnField = false;
						fieldMode = false;
					}
					moveClawsTo(1800);
					moveCraneTo(craneValsH[conesCount]);
					a1 = vexRT[Ch2];
					b1 = vexRT[Ch3];
					if(abs(a1) < 15){a1 = 0;}
					if(abs(b1) < 15){b1 = 0;}
					if(a1*b1 < 0){a1 = 3*a1/5;b1 = 3*b1/5;}
					moveRobot(a1,b1);

					delay(10);
				}
				//go back to eject claws position
				c = 0;
				while(!vexRT[Btn5DXmtr2] && goOnField)
				{
					if(vexRT[Btn8D])
					{
						goOnField = false;
						fieldMode = false;
					}
					moveCraneTo(craneValsH[conesCount]);
					if(SensorValue[clawsPot] < 2300){moveClawsTo(3300);motorReq[rollerMotor] = 30;}
					else{moveClawsWith(0);}
					a1 = vexRT[Ch2];
					b1 = vexRT[Ch3];
					if(abs(a1) < 15){a1 = 0;}
					if(abs(b1) < 15){b1 = 0;}
					if(a1*b1 < 0){a1 = 3*a1/5;b1 = 3*b1/5;}
					moveRobot(a1,b1);

					delay(10);
				}

				//go down to the desired crane Pos
				IErr = 0;
				while(!vexRT[Btn5UXmtr2] && goOnField)
				{
					if(vexRT[Btn8D])
					{
						goOnField = false;
						fieldMode = false;
					}
					if(SensorValue[craneEnc] > craneVals[conesCount])
					{
						moveCraneTo(craneVals[conesCount]);
					}
					else
					{
						moveCraneWith(0);
					}
					a1 = vexRT[Ch2];
					b1 = vexRT[Ch3];
					if(abs(a1) < 15){a1 = 0;}
					if(abs(b1) < 15){b1 = 0;}
					if(a1*b1 < 0){a1 = 3*a1/5;b1 = 3*b1/5;}
					moveRobot(a1,b1);

					delay(10);
				}
				//eject cone
				IErr = 0;
				clearTimer(T1);
				while(!vexRT[Btn5DXmtr2] && goOnField)
				{
					if(vexRT[Btn8D])
					{
						goOnField = false;
						fieldMode = false;
					}
					if(time1(T1) < 500){
						turnRollerToEject();
					}
					else
					{
						turnRollerToEject();
						moveCraneTo(craneValsH[conesCount]);
					}
					a1 = vexRT[Ch2];
					b1 = vexRT[Ch3];
					if(abs(a1) < 15){a1 = 0;}
					if(abs(b1) < 15){b1 = 0;}
					if(a1*b1 < 0){a1 = 3*a1/5;b1 = 3*b1/5;}
					moveRobot(a1,b1);

					delay(10);
				}
				motorReq[rollerMotor] = 0;
				//go back to mid pos and move crane Down
				IErr = 0;
				while(!vexRT[Btn5UXmtr2] && goOnField)
				{
					if(vexRT[Btn8D])
					{
						goOnField = false;
						fieldMode = false;
					}
					moveClawsTo(1800);
					moveCraneTo(0);
					a1 = vexRT[Ch2];
					b1 = vexRT[Ch3];
					if(abs(a1) < 15){a1 = 0;}
					if(abs(b1) < 15){b1 = 0;}
					if(a1*b1 < 0){a1 = 3*a1/5;b1 = 3*b1/5;}
					moveRobot(a1,b1);

					delay(10);
				}
			}
			if(conesCount == 0)
			{
				IErr = 0;
				while(!vexRT[Btn5DXmtr2] && goOnField)
				{
					if(vexRT[Btn8D])
					{
						goOnField = false;
						fieldMode = false;
					}
					moveClawsTo(1800);
					if(man_aut)
					{
						if(SensorValue[craneEnc] > 10)
						{moveCraneTo(0);}
						else
						{
							moveCraneWith(0);
						}
					}
					else
					{
						moveCraneWith(-127);
					}
					if(vexRT[Ch2Xmtr2] < -10)
					{
						man_aut = false;
					}
					else
					{
						man_aut = true;
					}
					a1 = vexRT[Ch2];
					b1 = vexRT[Ch3];
					if(abs(a1) < 15){a1 = 0;}
					if(abs(b1) < 15){b1 = 0;}
					if(a1*b1 < 0){a1 = 3*a1/5;b1 = 3*b1/5;}
					moveRobot(a1,b1);
					//CraneEncVal = SensorValue[CraneEnc];
					delay(10);
				}
				moveRobot(0,0);
				//claws down + Roller eating
				IErr = 0;
				while(!vexRT[Btn5UXmtr2] && goOnField)
				{
					if(vexRT[Btn8D])
					{
						goOnField = false;
						fieldMode = false;
					}
					moveClawsTo(1000);
					turnRollerToEat();
					if(vexRT[Ch2Xmtr2] < -20){
						moveCraneWith(vexRT[Ch2Xmtr2]);
					}
					else
					{
						moveCraneWith(0);
					}
					a1 = vexRT[Ch2];
					b1 = vexRT[Ch3];
					if(abs(a1) < 15){a1 = 0;}
					if(abs(b1) < 15){b1 = 0;}
					if(a1*b1 < 0){a1 = 3*a1/5;b1 = 3*b1/5;}
					moveRobot(a1,b1);

					delay(10);
				}
				IErr = 0;
				while(!vexRT[Btn5DXmtr2] && goOnField)
				{
					if(vexRT[Btn8D])
					{
						goOnField = false;
						fieldMode = false;
					}
					if(SensorValue[clawsPot] < 2300){moveClawsTo(3300);motorReq[rollerMotor] = 30;}
					else{moveClawsWith(0);}
					if(vexRT[Ch2Xmtr2] < -10){
						moveCraneWith(-127);
					}
					else
					{
						moveCraneWith(0);
					}
					a1 = vexRT[Ch2];
					b1 = vexRT[Ch3];
					if(abs(a1) < 15){a1 = 0;}
					if(abs(b1) < 15){b1 = 0;}
					if(a1*b1 < 0){a1 = 3*a1/5;b1 = 3*b1/5;}
					moveRobot(a1,b1);

					delay(10);
				}
				IErr = 0;
				clearTimer(T1);
				while(!vexRT[Btn5UXmtr2] && goOnField)
				{
					if(vexRT[Btn8D])
					{
						goOnField = false;
						fieldMode = false;
					}
					if(time1(T1) < 500){
						turnRollerToEject();
					}
					else
					{
						motorReq[rollerMotor] = 0;
					}
					if(vexRT[Ch2Xmtr2] < -10){
						moveCraneWith(-127);
					}
					else
					{
						moveCraneWith(0);
					}
					a1 = vexRT[Ch2];
					b1 = vexRT[Ch3];
					if(abs(a1) < 15){a1 = 0;}
					if(abs(b1) < 15){b1 = 0;}
					if(a1*b1 < 0){a1 = 3*a1/5;b1 = 3*b1/5;}
					moveRobot(a1,b1);
					delay(10);

				}
				motorReq[rollerMotor] = 0;
			}
			moveCraneWith(0);
			IErr = 0;
			while(true && goOnField)
			{
				if(vexRT[Btn6U])
				{
					motorReq[MobGoalntake] = 127;
				}
				else if(vexRT[Btn6D])
				{
					motorReq[MobGoalntake] = -127;
				}
				else
				{
					motorReq[MobGoalntake] = 0;
				}
				a1 = vexRT[Ch2];
				b1 = vexRT[Ch3];
				if(abs(a1) < 15){a1 = 0;}
				if(abs(b1) < 15){b1 = 0;}
				if(a1*b1 < 0){a1 = 3*a1/5;b1 = 3*b1/5;}
				moveRobot(a1,b1);
				if(vexRT[Btn8D])
				{
					goOnField = false;
					fieldMode = false;
					break;
				}
				if(conesCount > 0){
					moveClawsTo(1800);
				}
				//fieldMode = false;
				if(vexRT[Btn5U])
				{
					if(conesCount < 9)
					{
						conesCount = conesCount + 1;
					}
					break;
				}
				if(vexRT[Btn5D])
				{
					break;
				}
			}
		}
		else
		{
			if(feederMode)
			{
				int a1 = 0;
				int b1 = 0;
				//go to crane 0 + eat
				while(!vexRT[Btn5DXmtr2] && goOnFeeder)
				{
					if(vexRT[Btn7D])
					{
						goOnFeeder = false;
						feederMode = false;
					}
					if(vexRT[Btn7L] || vexRT[Btn7R])
					{
						goOnFeeder = false;
						feederMode = false;
						prefeeder = true;
					}
					moveClawsTo(2000);
					moveCraneTo(0);
					turnRollerToEat();
					//a1 = vexRT[Ch2];
					//b1 = vexRT[Ch3];
					//if(abs(a1) < 15){a1 = 0;}
					//if(abs(b1) < 15){b1 = 0;}
					//if(a1*b1 < 0){a1 = 3*a1/5;b1 = 3*b1/5;}
					moveRobot(a1,b1);
					//CraneEncVal = SensorValue[CraneEnc];
					delay(10);
				}
				motorReq[rollerMotor] = 0;
				moveClawsWith(0);
				//go to HVFeeder
				IErr = 0;
				while(!vexRT[Btn5UXmtr2] && goOnFeeder)
				{
					motorReq[rollerMotor] = 30;
					if(vexRT[Btn7D])
					{
						goOnFeeder = false;
						feederMode = false;
					}
					if(vexRT[Btn7L] || vexRT[Btn7R])
					{
						goOnFeeder = false;
						feederMode = false;
						prefeeder = true;
					}
					moveClawsTo(2000);
					if(SensorValue[craneEnc] < craneValsHFeeder[conesCount])
					{
						moveCraneTo(craneValsHFeeder[conesCount]);
					}
					else
					{
						moveCraneWith(0);
					}
					delay(10);
				}
				moveCraneWith(0);
				//claws back
				IErr = 0;
				while(!vexRT[Btn5DXmtr2] && goOnFeeder)
				{
					if(vexRT[Btn7D])
					{
						goOnFeeder = false;
						feederMode = false;
					}
					if(vexRT[Btn7L] || vexRT[Btn7R])
					{
						goOnFeeder = false;
						feederMode = false;
						prefeeder = true;
					}

					if(SensorValue[craneEnc] < craneValsHFeeder[conesCount])
					{
						moveCraneTo(craneValsHFeeder[conesCount]);
					}
					else
					{
						moveCraneWith(0);
					}
					if(SensorValue[clawsPot] < 2300){moveClawsTo(3300);motorReq[rollerMotor] = 30;}
					else{moveClawsWith(0);}
					delay(10);
				}
				//go down to desired position
				moveCraneWith(0);
				IErr = 0;
				while(!vexRT[Btn5UXmtr2] && goOnFeeder)
				{
					if(vexRT[Btn7D])
					{
						goOnFeeder = false;
						feederMode = false;
					}
					if(vexRT[Btn7L] || vexRT[Btn7R])
					{
						goOnFeeder = false;
						feederMode = false;
						prefeeder = true;
					}
					if(SensorValue[craneEnc] > craneVals[conesCount])
					{
						moveCraneTo(craneVals[conesCount]);
					}
					else
					{
						moveCraneWith(0);
					}
					delay(10);
				}
				//eject cone + go to HVFeeder
				clearTimer(T1);
				IErr = 0;
				while(!vexRT[Btn5DXmtr2] && goOnFeeder)
				{
					if(vexRT[Btn7D])
					{
						goOnFeeder = false;
						feederMode = false;
					}
					if(vexRT[Btn7L] || vexRT[Btn7R])
					{
						turnRollerToEject();
						goOnFeeder = false;
						feederMode = false;
						prefeeder = true;
					}
					if(time1(T1) < 700){
						turnRollerToEject();
					}
					else
					{
						turnRollerToEject();
						if(SensorValue[craneEnc] < craneValsHFeeder[conesCount])
						{
							moveCraneTo(craneValsHFeeder[conesCount]);
						}
						else
						{
							moveCraneWith(0);
						}
					}
					delay(10);
				}
				//move claws to forward
				IErr = 0;
				while(!vexRT[Btn5UXmtr2] && goOnFeeder)
				{
					if(vexRT[Btn7D])
					{
						goOnFeeder = false;
						feederMode = false;
					}
					if(vexRT[Btn7L] || vexRT[Btn7R])
					{
						goOnFeeder = false;
						feederMode = false;
						prefeeder = true;
					}
					moveClawsTo(2000);
					if(SensorValue[craneEnc] < craneValsHFeeder[conesCount])
					{
						moveCraneTo(craneValsHFeeder[conesCount]);
					}
					else
					{
						moveCraneWith(0);
					}
					delay(10);
				}
				IErr = 0;
				while(true && goOnFeeder)
				{
					moveClawsTo(1800);
					//fieldMode = false;
					if(vexRT[Btn7D])
					{
						goOnFeeder = false;
						feederMode = false;
						break;
					}
					if(vexRT[Btn7L] || vexRT[Btn7R])
					{
						goOnFeeder = false;
						feederMode = false;
						prefeeder = true;
						break;
					}
					if(vexRT[Btn5U])
					{
						if(conesCount < 9)
						{
							conesCount = conesCount + 1;
						}
						break;
					}
					if(vexRT[Btn5D])
					{
						break;
					}
				}
			}
		}

		int a = vexRT[Ch2];
		int b = vexRT[Ch3];
		if(abs(a) < 15){a = 0;}
		if(abs(b) < 15){b = 0;}
		if(a*b < 0){a = 3*a/5;b = 3*b/5;}

		motorReq[frontLeftExp] = b;
		motorReq[backLeft] = b;
		motorReq[frontRight1] = a;
		motorReq[frontRight2] = a;
		motorReq[backRight] = a;

	}
}




void moveClawsTo(int clawsTar)
{
	int Err = SensorValue[clawsPot] - clawsTar;
	moveClawsWith(0.1*Err);
}
void moveClawsWith(int speed)
{
	motorReq[rightClaws] = motorReq[leftClaws] = speed;
}
void moveCraneWith(int speed)
{
	motorReq[craneMotorsExp]= speed;
}
void moveCraneTo(int craneTar)
{
	int Errcr = -SensorValue[craneEnc] + craneTar;
	moveCraneWith(1.2*Errcr + 0.00001*IErrc);
	if(abs(1.2*Errcr + 0.00001*IErrc) < MAX_CMD)
	{
		IErrc = IErrc + Errcr;
	}
}
void moveRobot(int RSpeed, int LSpeed)
{
	motorReq[frontLeftExp] = LSpeed;
	motorReq[backLeft] = LSpeed;
	motorReq[frontRight1] = RSpeed;
	motorReq[frontRight2] = RSpeed;
	motorReq[backRight] = RSpeed;
}
void turnRollerToEat()
{
	motorReq[rollerMotor] = 127;
}
void turnRollerToEject()
{
	motorReq[rollerMotor] = -127;
}
