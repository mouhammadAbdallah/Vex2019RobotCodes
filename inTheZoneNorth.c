#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    leftCIPot,      sensorPotentiometer)
#pragma config(Sensor, in2,    rightCIPot,     sensorPotentiometer)
#pragma config(Sensor, in3,    MobPot,         sensorPotentiometer)
#pragma config(Sensor, in6,    backIR,         sensorLineFollower)
#pragma config(Sensor, in7,    frontIR,        sensorLineFollower)
#pragma config(Sensor, in8,    myGyro,         sensorGyro)
#pragma config(Sensor, dgtl1,  CraneEnc,       sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  CraneEncR,      sensorQuadEncoder)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           mobIntake1,    tmotorVex393_HBridge, openLoop, reversed)
#pragma config(Motor,  port2,           leftDrive,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           rightDrive,    tmotorVex393_MC29, openLoop, reversed, encoderPort, I2C_1)
#pragma config(Motor,  port4,           crane1,        tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           crane2,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           crane3,        tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           crane4,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           coneInLeft,    tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           coneInRight,   tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port10,          intakeMotor,   tmotorVex393HighSpeed_HBridge, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX2)

#pragma competitionControl(Competition)

#include "Vex_Competition_Includes.c"

#define MOTOR_NUM               kNumbOfTotalMotors
#define MOTOR_MAX_VALUE         127
#define MOTOR_MIN_VALUE         (-127)
#define MOTOR_DEFAULT_SLEW_RATE 30      // Default will cause 375mS from full fwd to rev
#define MOTOR_FAST_SLEW_RATE    256     // essentially off
#define MOTOR_TASK_DELAY        15      // task 1/frequency in mS (about 66Hz)
#define MOTOR_DEADBAND          10

void craneMove(int speed);
void initCraneEnc();
void moveClawsDown();
void moveClawsUp();
void stopClaws();
void moveStraight(int speed);
void moveRightDrive(int speed);
void moveLeftDrive(int speed);
void BrakeClaws(int pos);
void turnRollerToEat();
void turnRollerToEject();
void stopRoller();
void initGyro();
void craneMoveR(int speed);
void moveClawsWith(int speed);


//Claw's Position : 1 up , 2 mid , 3 Down
int motorReq[MOTOR_NUM];
int motorSlew[MOTOR_NUM];

task MotorSlewRateTask()
{
	int motorIndex;
	int motorTmp;


	// Initialize stuff
	for (motorIndex = 0; motorIndex < (signed)MOTOR_NUM; motorIndex++)
	{
		motorReq[motorIndex] = 0;
		motorSlew[motorIndex] = MOTOR_DEFAULT_SLEW_RATE;
	}

	// run task until stopped
	while (true)
	{
		// run loop for every motor
		for (motorIndex = 0; motorIndex < (signed)MOTOR_NUM; motorIndex++)
		{
			// So we don't keep accessing the internal storage
			motorTmp = motor[motorIndex];

			// Do we need to change the motor value ?
			if (motorTmp != motorReq[motorIndex])
			{
				// increasing motor value
				if (motorReq[motorIndex] > motorTmp)
				{
					motorTmp += motorSlew[motorIndex];
					// limit
					if (motorTmp > motorReq[motorIndex])
						motorTmp = motorReq[motorIndex];
				}

				// decreasing motor value
				if (motorReq[motorIndex] < motorTmp)
				{
					motorTmp -= motorSlew[motorIndex];
					// limit
					if (motorTmp < motorReq[motorIndex])
						motorTmp = motorReq[motorIndex];
				}

				// finally set motor
				motor[motorIndex] = motorTmp;
			}
		}

		// Wait approx the speed of motor update over the spi bus
		wait1Msec(MOTOR_TASK_DELAY);
	}
}

void pre_auton()
{
	initGyro();
	nMotorEncoder[rightDrive] = 0;
}
int steps = 0;
int threshold = 2000;
int MobileIntakePot = 0;
int craneTarR = 0;
task autonomous()
{
	startTask(MotorSlewRateTask);
	clearTimer(T1);
	while(time1(T1)<500)
	{
		motorReq[mobIntake1] = 127;
	}
	motorReq[mobIntake1] = 0;
	nMotorEncoder[rightDrive] = 0;
	while(nMotorEncoder[rightDrive] < 2300)
	{
		moveStraight(50);
	}
	moveStraight(0);
	clearTimer(T1);
	while(time1(T1)<1000)
	{
		motorReq[mobIntake1] = -127;
	}
	motorReq[mobIntake1] = 0;
	clearTimer(T1);
	while(time1(T1)<500)
	{
		craneMove(-80);
		craneMoveR(-80);
	}
	clearTimer(T1);
	while(time1(T1)<800)
	{
		turnRollerToEject();
	}
	clearTimer(T1);
	while(time1(T1)<1000)
	{
		stopRoller();
	}
	clearTimer(T1);
	while(time1(T1)<1000)
	{
		motorReq[mobIntake1] = 127;
	}
	motorReq[mobIntake1] = 0;
	nMotorEncoder[rightDrive] = 0;
	clearTimer(T1);
	while(time1(T1) < 1000)
	{
		moveStraight(-50);
	}
	moveStraight(0);
	////phase 2
	//nMotorEncoder[rightDrive] = 0;
	//while(nMotorEncoder[rightDrive] < 150)
	//{
	//	moveStraight(40);
	//}
	//moveStraight(0);
	//while(SensorValue[leftCIPot] > 1200)
	//{
	//	moveClawsDown();
	//}
	//////BrakeClaws(1);
	//////moveClawsWith(20);
	//clearTimer(T1);
	//while(time1(T1)<800)
	//{
	//	craneMove(-127);
	//	craneMoveR(-127);
	//	turnRollerToEat();
	//}
	//motor[intakeMotor] = 50;
	//while(SensorValue[CraneEnc] < 10 || SensorValue[CraneEncR] < 10)
	//{
	//	if(SensorValue[CraneEnc]<10){
	//		craneMove(80);
	//	}
	//	else
	//	{
	//		craneMove(0);
	//	}
	//	if(SensorValue[CraneEncR]<10){
	//		craneMoveR(80);
	//	}
	//	else
	//	{
	//		craneMoveR(0);
	//	}
	//}
	//craneMoveR(0);
	//craneMove(0);
	//while(SensorValue[leftCIPot] < 4000)
	//{
	//	moveClawsUp();
	//	motor[intakeMotor] = 50;
	//}
	//stopClaws();
	//clearTimer(T1);
	//while(time1(T1) < 500){}
	//clearTimer(T1);
	//while(time1(T1) < 1000)
	//{
	//	turnRollerToEject();
	//}
	//stopRoller();
	//////phase 3
	//nMotorEncoder[rightDrive] = 0;
	//while(nMotorEncoder[rightDrive] < 400)
	//{
	//	moveStraight(40);
	//}
	//moveStraight(0);
	//while(SensorValue[leftCIPot] > 1200)
	//{
	//	moveClawsDown();
	//}
	//////BrakeClaws(1);
	//////moveClawsWith(20);
	//clearTimer(T1);
	//while(time1(T1)<1000)
	//{
	//	craneMove(-127);
	//	craneMoveR(-127);
	//	turnRollerToEat();
	//}
	//motor[intakeMotor] = 50;
	//while(SensorValue[CraneEnc] < 30 || SensorValue[CraneEncR] < 30)
	//{
	//	if(SensorValue[CraneEnc]<30){
	//		craneMove(80);
	//	}
	//	else
	//	{
	//		craneMove(0);
	//	}
	//	if(SensorValue[CraneEncR]<30){
	//		craneMoveR(80);
	//	}
	//	else
	//	{
	//		craneMoveR(0);
	//	}
	//}
	//craneMoveR(0);
	//craneMove(0);
	//while(SensorValue[leftCIPot] < 4000)
	//{
	//	moveClawsUp();
	//	motor[intakeMotor] = 50;
	//}
	//stopClaws();
	//clearTimer(T1);
	//while(time1(T1) < 500){}
	//clearTimer(T1);
	//while(time1(T1) < 1000)
	//{
	//	turnRollerToEject();
	//}
	//stopRoller();
	//////delay(500);
	////////the second cone is on the goal
	//////clearTimer(T1);
	//////while(time1(T1) < 2000)
	//////{
	//////	int err = 0 - SensorValue[myGyro];
	//////	moveLeftDrive(-0.7*err);
	//////	moveRightDrive(0.7*err);
	//////}
	//moveStraight(0);
	//clearTimer(T1);
	//while(abs(nMotorEncoder[rightDrive]) < 2200 || time1(T1) < 1000)
	//{
	//	moveStraight(-50);
	//}
	//moveStraight(0);
	//delay(1000);
	//while(SensorValue[myGyro] > -700)
	//{
	//	moveRightDrive(-80);
	//	moveLeftDrive(10);
	//}
	//clearTimer(T1);
	//while(time1(T1) < 2000)
	//{
	//	int err = 900 - abs(SensorValue[myGyro]);
	//	moveLeftDrive(0.7*err);
	//	moveRightDrive(-0.7*err);
	//}
	//moveStraight(0);
	//clearTimer(T1);
	//while(time1(T1) < 2000)
	//{
	//	int err = 1350 - abs(SensorValue[myGyro]);
	//	moveLeftDrive(0.7*err);
	//	moveRightDrive(-0.7*err);
	//}
	//clearTimer(T1);
	//while(time1(T1) < 2000)
	//{
	//	int err = 1800 - abs(SensorValue[myGyro]);
	//	moveLeftDrive(0.7*err);
	//	moveRightDrive(-0.7*err);
	//}
	//nMotorEncoder[rightDrive] = 0;
	//while(nMotorEncoder[rightDrive] < 800)
	//{
	//	moveStraight(50);
	//}
	//moveStraight(0);
	//clearTimer(T1);
	//while(time1(T1) < 2000)
	//{
	//	int err = 1350 - abs(SensorValue[myGyro]);
	//	moveLeftDrive(0.7*err);
	//	moveRightDrive(-0.7*err);
	//}
	//moveStraight(0);
	//nMotorEncoder[rightDrive] = 0;
	//while(nMotorEncoder[rightDrive] < 1200)
	//{
	//	moveStraight(127);
	//}

	//moveStraight(0);
	//clearTimer(T1);
	//while(time1(T1) < 200){
	//	motor[mobIntake1] = 127;
	//}
	//motor[mobIntake1] = 0;
	//clearTimer(T1);
	//while(time1(T1) < 400){
	//	moveStraight(-50);
	//}
	//clearTimer(T1);
	//while(time1(T1) < 500){
	//	moveStraight(127);
	//}
	//moveStraight(0);
}
int CraneEncValue = 0;
bool goOnField = false;
bool goOnFeeder = false;
int craneTarField = 20;
int LeftPot = 0;
int RightPot = 0;
int craneEncRVal = 0;
bool initEating = false;
bool eating = false;
bool clawsUp = false;
bool clawsMoveUp = false;
bool clawsMoveDw = false;
bool turnToEat = false;
bool turnToEject = false;
bool feederMode = false;
int rightUpTar = 0;
int rightDwTar = 1950;
int leftUpTar = 2400;
int leftDwTar = 450;
int leftMidTar = 700;
int rightMidTar = 950;
int craneTar = 0;
int clawsTar = 0;
bool fixIt = false;
bool moveUp = false;
bool moveDown = false;
int gyroVal = 0;
int frontSensorVal = 0;
int currentPos = 0;
bool fieldMode = false;
bool moveUpToScore = false;
int countField = 0;


task usercontrol()
{
	// User control code here, inside the loop
	startTask(MotorSlewRateTask);
	craneMove(0);
	craneMoveR(0);
	clearTimer(T1);
	while(time1(T1) < 500){
		initCraneEnc();
	}
	initCraneEnc();
	clawsTar = SensorValue[leftCIPot];
	while (true)
	{
		frontSensorVal = SensorValue[frontIR];
		CraneEncValue = SensorValue[CraneEnc];
		CraneEncRVal = SensorValue[CraneEncR];
		MobileIntakePot = SensorValue[MobPot];
		LeftPot = SensorValue[leftCIPot];
		RightPot = SensorValue[rightCIPot];
		gyroVal = SensorValue[myGyro];
		if(vexRT[Btn7U])
		{
			feederMode = true;
			goOnFeeder = true;
			fieldMode = false;

		}
		if(vexRT[Btn8U])
		{
			fieldMode = true;
			goOnField = true;
			feederMode = false;
		}
		if(vexRT[Btn7D])
		{
			feederMode = false;
			goOnField = false;
		}
		while(vexRT[Btn6D])
		{
			motorReq[mobIntake1] = 127;
			craneTarField = 20;
			countField = 0;
		}
		motorReq[mobIntake1] = 0;
		while(vexRT[Btn6U])
		{
			motorReq[mobIntake1] = -127;
			//craneMove(10);
			//	motor[crane1] = 50;
		}
		//	motor[crane1] = 0;
		motorReq[mobIntake1] = 0;
		if(vexRT[Ch3Xmtr2] > 100)
		{
			moveUp = true;
			moveDown = false;
		}
		else if(vexRT[Ch3Xmtr2] <-100)
		{
			moveUp = false;
			moveDown = true;
		}
		else
		{
			moveUp = false;
			moveDown = false;
		}
		if(vexRT[Ch2Xmtr2] > 120)
		{
			clawsMoveUp = true;
			clawsMoveDw = false;
		}
		else if(vexRT[Ch2Xmtr2] < -120)
		{
			clawsMoveUp = false;
			clawsMoveDw = true;
		}
		else
		{
			clawsMoveUp = false;
			clawsMoveDw = false;
		}
		if(vexRT[Btn6UXmtr2])
		{
			turnToEat = true;
			turnToEject = false;
		}
		else if(vexRT[Btn6DXmtr2])
		{
			turnToEject = true;
			turnToEat = false;
		}
		else
		{
			turnToEject = false;
			turnToEat = false;
		}
		int craneTarFeeder = 20;
		while(feederMode)
		{
			//feederMode
			//move the crane to mid position
			int craneErr = 0;
			int craneErrR = 0;
			int clawsErr = 0;
			clawsTar = 2300;
			stopRoller();
			int IErr = 0;
			int IErrR = 0;
			int lastErr = 0;
			int lastErrR = 0;
			int Derr = 0;
			int DerrR = 0;
			bool reached = false;
			bool reachedR = false;
			int a1 = 0;
			int b1 = 0;
			while(!vexRT[Btn5UXmtr2] && goOnFeeder)
			{
				if(vexRT[Btn7D])
				{
					goOnFeeder = false;
					feederMode = false;
				}
				craneErr = 250 - SensorValue[CraneEnc];
				craneMove(0.5*craneErr);
				craneErrR = 250 - SensorValue[CraneEncR];
				craneMoveR(0.5*craneErrR);
				clawsErr = 2300 - SensorValue[leftCIPot];
				moveClawsWith(0.2*clawsErr);
				motor[intakeMotor]=40;
				a1 = vexRT[Ch2];
				b1 = vexRT[Ch3];
				if(abs(a1) < 15){a1 = 0;}
				if(abs(b1) < 15){b1 = 0;}
				if(a1*b1 < 0){a1 = 2*a1/5;b1 = 2*b1/5;}
				motorReq[rightDrive] = a1;
				motorReq[leftDrive] = b1;
				delay(10);
			}
			motorReq[rightDrive] = 0;
			motorReq[leftDrive] = 0;
			while(!vexRT[Btn5DXmtr2] && goOnFeeder)
			{
				if(vexRT[Btn7D])
				{
					goOnFeeder = false;
					feederMode = false;
				}
				clawsErr = 2300 - SensorValue[leftCIPot];
				moveClawsWith(0.2*clawsErr);
				if(SensorValue[CraneEnc] > 40){
					craneMove(-50);
					craneMoveR(-50);
				}
				else
				{
					craneMove(0);
					craneMoveR(0);
				}
				turnRollerToEat();
				delay(10);
			}
			stopRoller();
			while(!vexRT[Btn5UXmtr2] && goOnFeeder)
			{
				//edit here
				if(vexRT[Btn7D])
				{
					goOnFeeder = false;
					feederMode = false;
				}
				clawsErr = 2300 - SensorValue[leftCIPot];
				moveClawsWith(0.2*clawsErr);
				craneErr = craneTarFeeder - SensorValue[CraneEnc];
				craneMove(0.5*craneErr);
				craneErrR = craneTarFeeder - SensorValue[CraneEncR];
				craneMoveR(0.5*craneErrR);
				delay(10);
			}
			while(!vexRT[Btn5DXmtr2] && goOnFeeder)
			{

				if(vexRT[Btn7D])
				{
					goOnFeeder = false;
					feederMode = false;
				}
				craneErr = craneTarFeeder - SensorValue[CraneEnc];

				craneMove(0.8*craneErr);
				craneErrR = craneTarFeeder - SensorValue[CraneEncR];
				craneMoveR(0.8*craneErrR);
				if(SensorValue[leftCIPot] < 4000)
				{
					moveClawsUp();
				}
				else
				{
					stopClaws();
					turnRollerToEject();
				}
				delay(10);
			}
			stopRoller();
			while(!vexRT[Btn5UXmtr2] && goOnFeeder)
			{
				if(vexRT[Btn7D])
				{
					goOnFeeder = false;
					feederMode = false;
				}
				craneErr = 250 - SensorValue[CraneEnc];
				craneMove(0.5*craneErr);
				craneErrR = 250 - SensorValue[CraneEncR];
				craneMoveR(0.5*craneErrR);
				delay(10);
			}
			while(!vexRT[Btn5DXmtr2] && goOnFeeder)
			{
				if(vexRT[Btn7D])
				{
					goOnFeeder = false;
					feederMode = false;
				}
				craneErr = 250 - SensorValue[CraneEnc];
				craneMove(0.5*craneErr);
				craneErrR = 250 - SensorValue[CraneEncR];
				craneMoveR(0.5*craneErrR);
				clawsErr = 2300 - SensorValue[leftCIPot];
				moveClawsWith(0.2*clawsErr);
				delay(10);
			}
			while(true && goOnFeeder)
			{
				if(vexRT[Btn7D])
				{
					goOnFeeder = false;
					feederMode = false;
				}
				craneErr = 250 - SensorValue[CraneEnc];
				craneMove(0.5*craneErr);
				craneErrR = 250 - SensorValue[CraneEncR];
				craneMoveR(0.5*craneErrR);
				clawsErr = 3000 - SensorValue[leftCIPot];
				moveClawsWith(0.2*clawsErr);
				a1 = vexRT[Ch2];
				b1 = vexRT[Ch3];
				if(abs(a1) < 15){a1 = 0;}
				if(abs(b1) < 15){b1 = 0;}
				if(a1*b1 < 0){a1 = 3*a1/5;b1 = 3*b1/5;}
				motorReq[rightDrive] = a1;
				motorReq[leftDrive] = b1;
				while(vexRT[Btn6D])
				{
					motorReq[mobIntake1] = 127;
					motorReq[rightDrive] = 0;
					motorReq[leftDrive] = 0;
				}
				if(vexRT[Btn5U])
				{
					if(craneTarFeeder < 70){
						craneTarFeeder = craneTarFeeder + 30;
					}
					else
					{
						craneTarFeeder = craneTarFeeder + 30;
					}
					break;
				}
				if(vexRT[Btn5D])
				{
					break;
				}
				if(vexRT[Btn7D])
				{
					feederMode = false;
					break;
				}
			}
		}
		if(fieldMode)
		{
			int clawsErr = 0;
			int craneErr = 0;
			int craneErrR = 0;
			int a1 = 0;
			int b1 = 0;
			int kpField = 2;
			while(!vexRT[Btn5DXmtr2] && goOnField)
			{
				if(vexRT[Btn8D])
				{
					goOnField = false;
					fieldMode = false;
				}
				clawsErr = 2300 - SensorValue[leftCIPot];
				moveClawsWith(0.2*clawsErr);
				a1 = vexRT[Ch2];
				b1 = vexRT[Ch3];
				if(abs(a1) < 15){a1 = 0;}
				if(abs(b1) < 15){b1 = 0;}
				if(a1*b1 < 0){a1 = 3*a1/5;b1 = 3*b1/5;}
				motorReq[rightDrive] = a1;
				motorReq[leftDrive] = b1;
				CraneEncValue = SensorValue[CraneEnc];
				delay(10);
			}
			motorReq[rightDrive] = 0;
			motorReq[leftDrive] = 0;
			while(!vexRT[Btn5UXmtr2] && goOnField)
			{
				if(vexRT[Btn8D])
				{
					goOnField = false;
					fieldMode = false;
				}
				clawsErr = 1300 - SensorValue[leftCIPot];
				moveClawsWith(0.2*clawsErr);
				turnRollerToEat();
				delay(10);
			}
			while(!vexRT[Btn5DXmtr2] && goOnField)
			{
				if(vexRT[Btn8D])
				{
					goOnField = false;
					fieldMode = false;
				}
				motor[intakeMotor] = 50;
				clawsErr = 2400 - SensorValue[leftCIPot];
				moveClawsWith(0.4*clawsErr);
				motor[intakeMotor] = 50;
				CraneEncValue = SensorValue[CraneEnc];
				delay(10);
			}

			while(!vexRT[Btn5UXmtr2] && goOnField)
			{
				motor[intakeMotor] = 50;
				if(vexRT[Btn8D])
				{
					goOnField = false;
					fieldMode = false;
				}
				CraneEncValue = SensorValue[CraneEnc];
				craneErr = craneTarField - SensorValue[CraneEnc];
				craneErrR = craneTarField - SensorValue[CraneEncR];
				if(countField < 3){
					craneMove(craneErr);
					craneMoveR(craneErrR);
				}
				else
				{
					craneMove(0.7*craneErr);
					craneMoveR(0.7*craneErrR);
				}
				clawsErr = 2400 - SensorValue[leftCIPot];
				moveClawsWith(0.2*clawsErr);
				delay(10);
			}
			while(!vexRT[Btn5DXmtr2] && goOnField)
			{

				if(vexRT[Btn8D])
				{
					goOnField = false;
					fieldMode = false;
				}

				craneErr = craneTarField - SensorValue[CraneEnc];
				craneErrR = craneTarField - SensorValue[CraneEncR];
				if(countField < 3){
					craneMove(craneErr);
					craneMoveR(craneErrR);
				}
				else
				{
					craneMove(0.7*craneErr);
					craneMoveR(0.7*craneErrR);
				}
				if(SensorValue[leftCIPot] < 3900){moveClawsUp();motor[intakeMotor] = 50;}
				else{stopClaws();turnRollerToEject();}
				delay(10);
			}
			stopRoller();
			while(!vexRT[Btn5UXmtr2] && goOnField)
			{
				if(vexRT[Btn8D])
				{
					goOnField = false;
					fieldMode = false;
				}

				craneErr = craneTarField - SensorValue[CraneEnc];
				craneErrR = craneTarField - SensorValue[CraneEncR];
				if(countField < 3){
					craneMove(craneErr);
					craneMoveR(craneErrR);
				}
				else
				{
					craneMove(0.7*craneErr);
					craneMoveR(0.7*craneErrR);
				}
				clawsErr = 2400 - SensorValue[leftCIPot];
				moveClawsWith(0.2*clawsErr);
				delay(10);
			}
			int rErr = 0;
			int Err = 0;
			while(!vexRT[Btn5DXmtr2] && goOnField)
			{
				if(vexRT[Btn8D])
				{
					goOnField = false;
					fieldMode = false;
				}
				clawsErr = 2400 - SensorValue[leftCIPot];
				moveClawsWith(0.2*clawsErr);
				rErr = 0 - SensorValue[CraneEncR];
				Err = 0 - SensorValue[CraneEnc];
				craneMove(1.5*Err);
				craneMoveR(1.5*rErr);

				delay(10);
			}
			while(true && goOnField)
			{
				fieldMode = false;
				clawsErr = 2300 - SensorValue[leftCIPot];
				moveClawsWith(0.2*clawsErr);
				if(vexRT[Btn7L])
				{
					craneTarField = craneTarField + 20;
					break;
				}
				if(vexRT[Btn5U])
				{
					countField = countField + 1;
					if(craneTarField < 150){
						craneTarField = craneTarField + 40;
					}
					else
					{
						craneTarField = craneTarField + 40;
					}
					break;
				}
				if(vexRT[Btn5D])
				{
					break;
				}
			}
		}
		else
		{
			if(vexRT[Btn7UXmtr2])
			{
				moveUpToScore = true;
			}
			if(vexRT[Btn7DXmtr2])
			{
				moveUpToScore = false;
			}
			if(moveUpToScore & !moveUp & !moveDown)
			{
				int Err = 0;
				int rErr = 0;
				Err = 300 - SensorValue[CraneEnc];
				rErr = 300 - SensorValue[CraneEncR];
				craneMove(Err);
				craneMoveR(rErr);
			}
			if(moveDown & !moveUpToScore)
			{
				craneMove(-127);
				craneMoveR(-127);
			}
			if(!moveUp && !moveDown && !moveUpToScore)
			{
				craneMove(0);
				craneMoveR(0);
			}

			if(moveUp)
			{
				craneMove(127);
				craneMoveR(127);
			}
			if(clawsMoveUp)
			{
				moveClawsUp();
				clawsTar = SensorValue[leftCIPot]+200;
			}
			if(clawsMoveDw)
			{
				moveClawsDown();
				clawsTar = SensorValue[leftCIPot];
			}
			if(!clawsMoveUp && !clawsMoveDw)
			{
				if(clawsTar > 3500)
				{
					moveClawsWith(0);
				}
				else
				{
					int err = clawsTar - SensorValue[leftCIPot];
					moveClawsWith(0.1*err);
				}

			}
			if(turnToEat)
			{
				turnRollerToEat();
			}
			if(vexRT[Btn8LXmtr2])
				{
					initCraneEnc();
				}
			if(turnToEject){turnRollerToEject();}
			if(!turnToEat && ! turnToEject) {stopRoller();}
			int a = vexRT[Ch2];
			int b = vexRT[Ch3];
			if(abs(a) < 15){a = 0;}
			if(abs(b) < 15){b = 0;}
			if(a*b < 0){a = 3*a/5;b = 3*b/5;}
			motorReq[rightDrive] = a;
			motorReq[leftDrive] = b;
		}
	}
}

void craneMove(int speed)
{

	motorReq[crane2] = speed;
	motorReq[crane3] = speed;

}
void craneMoveR(int speed)
{

	motorReq[crane1] = speed;
	motorReq[crane4] = speed;
}
void initCraneEnc()
{
	SensorValue[CraneEnc] = 0;
	SensorValue[CraneEncR] = 0;
}

void moveClawsDown()
{
	motorReq[coneInRight] = -127;
	motorReq[coneInLeft] = -127;
}

void BrakeClaws(int pos)
{
	stopClaws();
	clearTimer(T1);
	while(time1(T1)<100)
	{
		if (pos == 0) // robot crane was going up
		{
			motorReq[coneInRight] = -50;
			motorReq[coneInLeft] = -50;
		}
		if (pos == 1) // was going down
		{
			motorReq[coneInRight] = 50;
			motorReq[coneInLeft] = 50;
		}
	}
	stopClaws();
}
void moveClawsUp()
{
	motorReq[coneInRight] = 127;
	motorReq[coneInLeft] = 127;
}
void stopClaws()
{
	motorReq[coneInLeft] 	= 0;
	motorReq[coneInRight] 	= 0;
}
void turnRollerToEat()
{
	motorReq[intakeMotor] = 127;
}
void turnRollerToEject()
{
	motorReq[intakeMotor] = -127;
}
void stopRoller()
{
	motorReq[intakeMotor] = 0;
}

void initGyro()
{
	SensorValue[myGyro] = 0;
}
void moveClawsWith(int speed)
{
	motorReq[coneInLeft] = motorReq[coneInRight] = speed;
}
void moveStraight(int speed)
{
	motorReq[leftDrive] = motorReq[rightDrive] = speed;
}
void moveRightDrive(int speed)
{
	motorReq[rightDrive] = speed;
}
void moveLeftDrive(int speed)
{
	motorReq[leftDrive] = speed;
}
