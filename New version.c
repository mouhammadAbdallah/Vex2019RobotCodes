#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    myGyro,         sensorGyro)
#pragma config(Sensor, in2,    clawsPot,       sensorPotentiometer)
#pragma config(Sensor, in3,    backLim,        sensorLineFollower)
#pragma config(Sensor, in4,    frontLim,       sensorLineFollower)
#pragma config(Sensor, in5,    frontLim2,      sensorLineFollower)
#pragma config(Sensor, dgtl1,  craneEnc,       sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  RightBump,      sensorTouch)
#pragma config(Sensor, dgtl4,  LeftBump,       sensorTouch)
#pragma config(Sensor, dgtl5,  AdjtSwitch,     sensorTouch)
#pragma config(Sensor, dgtl6,  RorB,           sensorTouch)
#pragma config(Sensor, dgtl7,  AdjtSwitch2,    sensorTouch)
#pragma config(Sensor, dgtl8,  leftEnc,        sensorQuadEncoder)
#pragma config(Sensor, dgtl12, emergAut,       sensorTouch)
#pragma config(Sensor, I2C_1,  enc1,           sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           MobGoalntake,  tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           frontRight1,   tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           frontLeftExp,  tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port4,           rightClaws,    tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           backRight,     tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           backLeft,      tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port7,           leftClaws,     tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port8,           craneMotorsExp, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           frontRight2,   tmotorVex393HighSpeed_MC29, openLoop, reversed, encoderPort, I2C_1)
#pragma config(Motor,  port10,          rollerMotor,   tmotorVex393_HBridge, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX2)
#pragma competitionControl(Competition)

#include "Vex_Competition_Includes.c"
#define MOTOR_NUM               kNumbOfTotalMotors
#define MOTOR_MAX_VALUE         127
#define MOTOR_MIN_VALUE         (-127)
#define MOTOR_DEFAULT_SLEW_RATE 30      // Default will cause 375mS from full fwd to rev
#define MOTOR_FAST_SLEW_RATE    256     // essentially off
#define MOTOR_TASK_DELAY        20      // task 1/frequency in mS (about 66Hz)
#define MOTOR_DEADBAND          10
#define MAX_CMD									127

void moveClawsTo(int clawsTar);
void moveClawsWith(int speed);
void moveCraneWith(int speed);
void moveCraneTo(int craneTar);
void moveRobot(int RSpeed, int LSpeed);
void turnRollerToEject();
void turnRollerToEat();

int motorReq[MOTOR_NUM];
int motorSlew[MOTOR_NUM];

//Variables :
bool Blue = false;
bool holdStack = false;
bool holdStackClicked = false;
int Err = 0;
int Errd = 0;
int IErr = 0;
int IErrd = 0;
int IErrc = 0;
int Errc = 0;

int craneVals[10] = {0,0,40,80,110,150,200,250,290,320};
int craneValsH[10] = {0,75,105,150,200,250,300,350,400,450};
int craneValsHFeeder[10] = {60,70,100,160,220,250,290,320,370,440};
int craneValsStat[5] = {200,240,290,340,390};
int craneValsStatH[5] = {300,350,380,440,480};

bool statGoalMode = false;
bool goOnStat = false;
bool postfield = false;
bool prefield = false;
bool fieldMode = false;
bool goOnField = false;
bool goOnFeeder = false;
bool clawsRecv= false;
bool prefeeder = false;
bool feederMode = false;
bool MobInDown = false;
bool MobInUp = false;
int conesCount = 0;
int statCount = 0;

int test1 = 0;
int test2 = 0;
int test3 = 0;

// * is used as gyro measurement unit
// ~ is used as encoder unit

task MotorSlewRateTask()
{
	int motorIndex;
	int motorTmp;


	// Initialize stuff
	for (motorIndex = 0; motorIndex < (signed)MOTOR_NUM; motorIndex++)
	{
		motorReq[motorIndex] = 0;
		motorSlew[motorIndex] = MOTOR_DEFAULT_SLEW_RATE;
	}

	// run task until stopped
	while (true)
	{
		// run loop for every motor
		for (motorIndex = 0; motorIndex < (signed)MOTOR_NUM; motorIndex++)
		{
			// So we don't keep accessing the internal storage
			motorTmp = motor[motorIndex];

			// Do we need to change the motor value ?
			if (motorTmp != motorReq[motorIndex])
			{
				// increasing motor value
				if (motorReq[motorIndex] > motorTmp)
				{
					motorTmp += motorSlew[motorIndex];
					// limit
					if (motorTmp > motorReq[motorIndex])
						motorTmp = motorReq[motorIndex];
				}

				// decreasing motor value
				if (motorReq[motorIndex] < motorTmp)
				{
					motorTmp -= motorSlew[motorIndex];
					// limit
					if (motorTmp < motorReq[motorIndex])
						motorTmp = motorReq[motorIndex];
				}

				// finally set motor
				motor[motorIndex] = motorTmp;
			}
		}

		// Wait approx the speed of motor update over the spi bus
		wait1Msec(MOTOR_TASK_DELAY);
	}
}

void pre_auton()
{
	bStopTasksBetweenModes = true;
	SensorValue[craneEnc] = 0;
	SensorValue[myGyro] = 0;
	nMotorEncoder[frontRight2] = 0;
}


task autonomous()
{
	startTask(MotorSlewRateTask);
	SensorValue[myGyro]= 0;
	if(SensorValue[emergAut] == 1)
	{

		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		////////////////////////									E M E R G E N C Y									///////////////////////////////////////
		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////



		// move crane up
		nMotorEncoder[frontRight2] = 0;
		while(SensorValue[craneEnc] < 250)
			moveCraneTo(300);

		// move robot straight foreward with a gyro P
		nMotorEncoder[frontRight2] = 0;
		while(nMotorEncoder[frontRight2] < 200)
		{
			Err = SensorValue[myGyro]; //  desired value = 0
			moveRobot(50 - 0.5*Err,50 + 0.5*Err);
			moveClawsTo(2300);
			moveCraneTo(300);
		}
		moveRobot(0,0);

		// lower crane a little bit after arriving to the stationnary goal
		clearTimer(T1);
		while(time1(T1) < 1000)
		{
			moveClawsTo(2300);
			moveCraneTo(200);
		}

		// eject cone to score
		clearTimer(T2);
		while(time1(T2) < 500)
		{
			turnRollerToEject();
			moveClawsTo(2300);
			moveCraneTo(200);
		}

		// move crane up (roller still ejecting cone)
		clearTimer(T1);
		while(time1(T1) < 1000)
		{
			moveClawsTo(2300);
			moveCraneTo(300);
		}

		// turn off roller and return claws to the starting position
		motorReq[rollerMotor] = 0;
		clearTimer(T2);
		while(time1(T1) < 1000)
		{
			if(SensorValue[clawsPot] < 2600){moveClawsTo(3300);}
			else
			{
				moveClawsWith(0);
			}
			moveCraneTo(300);
		}

		// get the crane down to the starting position
		while(time1(T1) < 1000)
		{
			if(SensorValue[craneEnc] > 10)
			{
				moveCraneWith(-127);
			}
			else
			{
				moveCraneWith(0);
			}
		}

		// turn off crane and stop
		moveCraneWith(0);
		while(true);

	}

	///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////				      A U T O N O M O U S	      			/////////////////////////////////////////
	///////////////////////////////////////////////////////////////////////////////////////////////////////////////////


	/////////////////////////////////////////////////////////////////////////////////////// Getting First Mobile goal
	if(SensorValue[RorB] == 0)
	{
		Blue = true;
	}
	else
	{
		Blue = false;
	}
	nMotorEncoder[frontRight2] = 0;
	Err = 0;
	clearTimer(T1);
	IErr = 0;

	// move forward straight using gyro P for 1100~ then look for white line while lowering mobile goal intake + WATCHDOG
	while(nMotorEncoder[frontRight2] < 1100 || SensorValue[backLim] > 1700)
	{
		Err = SensorValue[myGyro];
		IErr = IErr + Err;
		moveRobot(60 - 0.6*Err - 0.0001*IErr,60 + 0.6*Err + 0.0001*IErr);
		if(time1(T1) < 900)
		{
			motorReq[MobGoalntake] = -127;
		}
		else
		{
			motorReq[MobGoalntake] = 0;
		}
		if(time1(T1) > 5000) // 5 seconds watchdog
		{
			while(true)
			{
				moveRobot(0,0);
			}
		}
	}
	moveRobot(0,0);

	// brake after arriving to the line
	clearTimer(T2);
	while(time1(T2)<100)
	{
		moveRobot(-50,-50);
	}
	moveRobot(0,0);

	// move straight foreward using gyro PI for 150~
	nMotorEncoder[frontRight2] = 0;
	SensorValue[leftEnc] = 0;
	IErr = 0;
	if(Blue)
	{
		while(nMotorEncoder[frontRight2] < 150)
		{
			IErr = IErr + Err;
			Err = SensorValue[myGyro];
			moveRobot(40 - 0.8*Err - 0.0003*IErr,40 + 0.8*Err + 0.0003*IErr);
		}
	}
	else
	{
		while(SensorValue[leftEnc] < 150)
		{
			IErr = IErr + Err;
			Err = SensorValue[myGyro];
			moveRobot(40 - 0.8*Err - 0.0003*IErr,40 + 0.8*Err + 0.0003*IErr);
		}
	}
	moveRobot(0,0);

	// move up the mobile goal intake while turning (adjusting) to the zero angle position using gyro
	IErr = 0;
	clearTimer(T1);
	while(time1(T1)<1250)
	{
		IErr = IErr + Err;
		motorReq[MobGoalntake] = 127;
		Err = SensorValue[myGyro];
		moveRobot(-0.6*Err,0.6*Err);
	}
	moveRobot(0,0);
	motorReq[MobGoalntake] = 0;


	/////////////////////////////////////////////////////////////////////////////////////////////// Ejecting Preload

	// the mobile goal is ready, eject the first cone (preload)
	clearTimer(T1);
	while(time1(T1)<500)
	{
		turnRollerToEject();
	}

	//////////////////////////////////////////////////////////////////////////////////////////// Getting Second Cone

	motorReq[rollerMotor] = 0;
	nMotorEncoder[frontRight2] = 0;
	SensorValue[leftEnc] = 0;

	// move claws to mid position
	clearTimer(T2);
	while(time1(T2) < 1000)
	{
		moveClawsTo(1800);
	}

	// move foreward tilted 50* using gyro PI for 100~
	IErr = 0;
	if(Blue)
	{
		while(nMotorEncoder[frontRight2] < 100)
		{
			moveClawsTo(1800);
			Err = SensorValue[myGyro] - 50;
			IErr = IErr + Err;
			moveRobot(60 - 0.5*Err - 0.0001*IErr,30 + 0.5*Err+0.0001*IErr);
		}
	}
	else
	{
		while(SensorValue[leftEnc] < 80)
		{
			moveClawsTo(1800);
			Err = SensorValue[myGyro] + 40;
			IErr = IErr + Err;
			moveRobot(30 - 0.5*Err - 0.0001*IErr,60 + 0.5*Err+0.0001*IErr);
		}
	}
	moveRobot(0,0);

	// get down claws to eating position and turn roller on to eat the second cone
	clearTimer(T1);
	while(time1(T1) < 800)
	{
		moveClawsTo(1000);
		turnRollerToEat();
		//Err = SensorValue[myGyro];
		//moveRobot(-0.6*Err,0.6*Err);
	}

	// hold the cone by giving low pwer to the roller
	motorReq[rollerMotor] = 30;
	moveClawsWith(0);
	moveRobot(0,0);

	// move claws to up position
	clearTimer(T2);
	while(time1(T2) < 1000)
	{
		//Err = SensorValue[myGyro];
		//moveRobot(-0.6*Err,0.6*Err);
		moveCraneTo(40);
		if(SensorValue[clawsPot] < 2500)
		{
			moveClawsTo(3300);
		}
		else
		{
			moveClawsWith(0);
		}
	}

	// eject second cone
	clearTimer(T2);
	while(time1(T2) < 500)
	{
		turnRollerToEject();
	}
	motorReq[rollerMotor] = 0;

	//////////////////////////////////////////////////////////////////////////////////////////// Getting Third Cone

	// move claws to mid position
	clearTimer(T2);
	while(time1(T2) < 800)
	{
		moveClawsTo(1800);
		//Err = SensorValue[myGyro];
		//moveRobot(-0.6*Err,0.6*Err);
	}

	//clearTimer(T2);
	//while(time1(T2) < 800)
	//{
	//	Err = SensorValue[myGyro];
	//	//moveRobot(-0.6*Err,0.6*Err);
	//	moveClawsTo(1800);
	//	if(SensorValue[craneEnc] > 10)
	//	{
	//		moveCraneTo(0);
	//	}
	//	else
	//	{
	//		moveCraneWith(0);
	//	}
	//}
	nMotorEncoder[frontRight2] = 0;
	SensorValue[leftEnc] = 0;
	IErr = 0;

	// move foreward tilted 50* using gyro PI for 220~ while lowering crane and holding claws to mid position + WATCHDOG
	if(Blue)
	{
		clearTimer(T1);
		while(nMotorEncoder[frontRight2] < 220)
		{
			//moveClawsTo(1800);
			if(SensorValue[craneEnc] > 10)
			{
				moveCraneTo(0); // move crane down
			}
			else
			{
				moveCraneWith(0); // turn off crane
			}

			moveClawsTo(1800);
			Err = SensorValue[myGyro] - 50;
			IErr = IErr + Err;
			moveRobot(50 - 0.4*Err - 0.000*IErr,50 + 0.4*Err+0.000*IErr);
			if(time1(T1) > 1000) // 1 sec watchdog
			{
				break;
			}
		}
	}
	else
	{
		clearTimer(T1);
		while(SensorValue[leftEnc] < 220)
		{
			if(SensorValue[craneEnc] > 10)
			{
				moveCraneTo(0);
			}
			else
			{
				moveCraneWith(0);
			}
			moveClawsTo(1800);
			Err = SensorValue[myGyro] + 40;
			IErr = IErr + Err;
			moveRobot(50 - 0.4*Err - 0.000*IErr,50 + 0.4*Err+0.000*IErr);
			if(time1(T1) > 1000)
			{
				break;
			}
		}
	}
	moveRobot(0,0);

	// get claws down to eating position and turn roller on to eat the third cone
	clearTimer(T1);
	while(time1(T1) < 800)
	{
		moveClawsTo(1000);
		turnRollerToEat();
		//Err = SensorValue[myGyro];
		//moveRobot(-0.6*Err,0.6*Err);
	}

	// hold the cone with 30 roller power
	motorReq[rollerMotor] = 30;
	moveClawsWith(0);
	moveRobot(0,0);
	IErr = 0;
	//clearTimer(T2);
	//while(time1(T2) < 1200)
	//{
	//	Err = SensorValue[myGyro];
	//	//moveRobot(-0.6*Err,0.6*Err);
	//	moveCraneTo(100);
	//	if(time1(T2) > 500)
	//	{
	//		if(SensorValue[clawsPot] < 2500)
	//		{
	//			moveClawsTo(3300);
	//		}
	//		else
	//		{
	//			moveClawsWith(0);
	//		}
	//	}
	//}
	//clearTimer(T1);
	//while(time1(T1) < 500)
	//{
	//	turnRollerToEject();
	//}
	motorReq[rollerMotor] = 30;
	nMotorEncoder[frontRight2] = 0;
	IErrd = 0;
	IErr = 0;
	IErrc = 0;

	// move backward tilted 10* using gyro PI for 1100~ then look for white line using back sensor while:
	// 1.   moving crane up to 100~					(always)
	// 2.   moving claws to up position  		(0.5 < t < 1.2 secs)
	// 3.   turning roller to eject cone 		(t >1.4 secs)
	if(Blue)
	{
		clearTimer(T2);
		while(abs(nMotorEncoder[frontRight2]) < 1100 || SensorValue[backLim] > 1700)
		{
			if(time1(T2) < 1200)
			{
				moveCraneTo(100);
				if(time1(T2) > 500)
				{
					if(SensorValue[clawsPot] < 2500)
					{
						moveClawsTo(3300);
					}
					else
					{
						moveClawsWith(0);
					}
				}
			}
			if(time1(T2) > 1400)
			{
				turnRollerToEject();
			}
			Errd = SensorValue[myGyro] + 10;
			IErrd = IErrd + Errd;
			moveRobot(-80 - 1*Errd - 0.0001*IErrd,-80 + 1*Errd + 0.0001*IErrd);

			moveCraneTo(100);
		}
	}
	else
	{
		clearTimer(T2);
		while(abs(nMotorEncoder[frontRight2]) < 1100 || SensorValue[backLim] > 1700)
		{
			if(time1(T2) < 1200)
			{
				moveCraneTo(100);
				if(time1(T2) > 500)
				{
					if(SensorValue[clawsPot] < 2500)
					{
						moveClawsTo(3300);
					}
					else
					{
						moveClawsWith(0);
					}
				}
			}
			if(time1(T2) > 1400)
			{
				turnRollerToEject();
			}
			Errd = SensorValue[myGyro] - 10;
			IErrd = IErrd + Errd;
			moveRobot(-80 - 1*Errd - 0.0001*IErrd,-80 + 1*Errd + 0.0001*IErrd);

			moveCraneTo(100);
		}
	}
	moveRobot(0,0);
	motorReq[rollerMotor] = 0;

	//////////////////////////////////////////////////////////////////////////////////////// Scoring First Mobile Goal

	// little push to move backwards to be able to turn smoothly without toutching the fence
	clearTimer(T1);
	while(time1(T1) < 150)
	{
		moveRobot(-60,-60);
	}
	moveRobot(0,0);


	if(Blue)
	{
		// BLUE : turn 450* (high power then P control) using gyro
		while(SensorValue[myGyro] < 300)
		{
			moveRobot(60,-60);
		}
		moveRobot(0,0);
		clearTimer(T1);
		while(time1(T1) < 800)
		{
			Err = SensorValue[myGyro] - 450;
			moveRobot(-0.3*Err,0.3*Err);
		}
		moveRobot(0,0);

		// BLUE : move backward tilted 450* for 0.2 secs then for 700~
		nMotorEncoder[frontRight2] = 0;
		clearTimer(T1);
		while(nMotorEncoder[frontRight2] > -700 || time1(T1) < 200)
		{
			moveCraneTo(100);
			Err = SensorValue[myGyro] - 450;
			moveRobot(-60 - 0.8*Err,-60 + 0.8*Err);
		}
		moveRobot(0,0);

		//BLUE : turn 1350* (high power then P control) using gyro to be perpendicular to the starting bar
		while(SensorValue[myGyro] < 1200)
		{
			moveRobot(60,-60);
		}
		moveRobot(0,0);
		clearTimer(T1);
		while(time1(T1)<1000)
		{
			Err = SensorValue[myGyro] - 1350;
			moveRobot(-0.4*Err,0.4*Err);
		}

	}
	else
	{
		// RED : turn 450* (high power then P control) using gyro
		while(SensorValue[myGyro] > -300)
		{
			moveRobot(-60,60);
		}
		moveRobot(0,0);
		clearTimer(T1);
		while(time1(T1) < 800)
		{
			Err = SensorValue[myGyro] + 450;
			moveRobot(-0.3*Err,0.3*Err);
		}
		moveRobot(0,0);

		// RED : move backward tilted 450* for 0.2 secs then for 600~
		nMotorEncoder[frontRight2] = 0;
		clearTimer(T1);
		while(nMotorEncoder[frontRight2] > -600 || time1(T1) < 400)
		{
			moveCraneTo(100);
			Err = SensorValue[myGyro] + 450;
			moveRobot(-60 - 0.8*Err,-60 + 0.8*Err);
		}
		moveRobot(0,0);

		// RED : turn 1350* (high power then P control) using gyro to be perpendicular to the starting bar
		while(SensorValue[myGyro] > -1200)
		{
			moveRobot(-60,60);
		}
		moveRobot(0,0);
		clearTimer(T1);
		while(time1(T1)<1000)
		{
			Err = SensorValue[myGyro] + 1350;
			moveRobot(-0.4*Err,0.4*Err);
		}
	}

	// move foreward for 1.2 secs with full power while lowering mobile goal intake
	clearTimer(T1);
	while(time1(T1) < 1200)
	{
		moveRobot(55,55);
		if(time1(T1) > 400)
		{
			motorReq[MobGoalntake] = -127;
		}
	}
	motorReq[MobGoalntake]  = 30;
	moveRobot(0,0);

	// wait 0.5 secs
	clearTimer(T1);
	while(time1(T1) < 500)
	{
		moveRobot(0,0);
	}
	moveRobot(0,0);
	moveCraneWith(0);

	// go backwards full power for 0.1 sec
	clearTimer(T1);
	while(time1(T1) < 100)
	{
		moveRobot(-127,-127);
	}
	moveRobot(0,0);


	//clearTimer(T1);
	//while(time1(T1) < 400)
	//{
	//	moveRobot(70,70);
	//}
	//moveRobot(0,0);
	//clearTimer(T1);
	//while(time1(T1) < 300)
	//{
	//	moveRobot(-70,-70);
	//}
	//moveRobot(0,0);

	// go foreward again full power for 0.4 secs
	clearTimer(T1);
	while(time1(T1) < 400)
	{
		moveRobot(127,127);
	}
	moveRobot(0,0);

	// move up the mobile goal intake
	nMotorEncoder[frontRight2] = 0;
	clearTimer(T1);
	while(time1(T1) < 600)
	{
		motorReq[MobGoalntake] = 127;
	}
	motorReq[MobGoalntake] = 0;

	// move backwards for 500~ while lowering crane, and lower mobile goal intake in the 10 point zone (just in case)
	while(abs(nMotorEncoder[frontRight2]) < 500)
	{
		moveCraneTo(0);
		if(abs(nMotorEncoder[frontRight2])> 100)
		{
			motorReq[MobGoalntake] = -127;
		}
		else
		{
			motorReq[MobGoalntake] = 0;
		}
		moveRobot(-50,-50);
	}
	moveRobot(0,0);

	// brake
	clearTimer(T1);
	while(time1(T1) < 100)
	{
		moveRobot(50,50);
	}
	moveRobot(0,0);

	// move up mobile goal intake
	clearTimer(T1);
	while(time1(T1) < 500)
	{
		motorReq[MobGoalntake] = 127;
	}
	motorReq[MobGoalntake] = 0;

	//////////////////////////////////////////////////////////////////////////////////////////// Getting Fourth Cone

	// RESET GYRO perpendicular to the starting bar
	SensorValue[myGyro] = 0;
	if(Blue)
	{
		// BLUE : turn slightly more than 600*
		while(SensorValue[myGyro] > -600)
		{
			moveRobot(-50,50);
		}
		moveRobot(0,0);

		// BLUE : move backwards tilted 900* (parallel to the starting bar) until reaching wall
		while(SensorValue[AdjtSwitch] == 0)
		{
			Err = SensorValue[myGyro] + 900;
			moveRobot(-40 - 0.3*Err, -40 + 0.3*Err);
		}
		moveRobot(0,0);

		// BLUE : move foreward 0.2 secs to be able to turn smoothly without touching the wall
		clearTimer(T1);
		while(time1(T1) < 200)
		{
			moveRobot(50,50);
		}
		moveRobot(0,0);

		// BLUE : turn to adjust to the wall
		while(SensorValue[myGyro] > -1250)
		{
			moveRobot(-70,0);
		}
		moveRobot(0,0);

		// BLUE : move backwards for 0.25 secs or until the 2 bumpers are pushed together
		clearTimer(T1);
		clearTimer(T2);
		while(true)
		{
			moveRobot(-40,-40);
			if(time1(T1) > 250 || time1(T2) > 250 || (SensorValue[LeftBump] == 1 && SensorValue[RightBump] == 1))
			{
				break;
			}
		}
	}
	else
	{
		// RED : turn slightly more than 600*
		while(SensorValue[myGyro] < 600)
		{
			moveRobot(60,-60);
		}
		moveRobot(0,0);

		// RED : move backwards tilted 900* (parallel to the starting bar) until reaching wall
		while(SensorValue[AdjtSwitch2] == 0)
		{
			Err = SensorValue[myGyro] - 900;
			moveRobot(-40 - 0.3*Err, -40 + 0.3*Err);
		}
		moveRobot(0,0);

		// RED : move foreward 0.1 secs to be able to turn smoothly without touching the wall
		clearTimer(T1);
		while(time1(T1) < 100)
		{
			moveRobot(50,50);
		}
		moveRobot(0,0);

		// RED : turn to adjust to the wall
		while(SensorValue[myGyro] < 1350)
		{
			moveRobot(0,-70);
		}
		moveRobot(0,0);

		// RED : move backwards for 0.25 secs or until the 2 bumpers are pushed together
		clearTimer(T2);
		clearTimer(T1);
		while(true)
		{
			moveRobot(-40,-40);
			if(time1(T2) > 250 || time1(T1) > 250 || (SensorValue[LeftBump] == 1 && SensorValue[RightBump] == 1))
			{
				break;
			}
		}
	}
	moveRobot(0,0);

	// RESET GYRO while touching wall
	SensorValue[myGyro] = 0;

	// move foreward 380~
	nMotorEncoder[frontRight2] = 0;
	while(nMotorEncoder[frontRight2] < 380)
	{
		moveRobot(50,50);
	}
	moveRobot(0,0);

	// brake
	clearTimer(T2);
	while(time1(T2) < 100)
	{
		moveRobot(-50,-50);
	}
	moveRobot(0,0);

	// turn 900* to face the cone, then move straight foreward with gyro P for 800~, then until white line detection
	clearTimer(T1);
	moveCraneWith(0);
	if(Blue)
	{
		// turn
		while(SensorValue[myGyro] > -600)
		{
			moveRobot(-60,60);
		}
		moveRobot(0,0);
		Err = 0;
		clearTimer(T1);
		while(time1(T1) < 1000)
		{
			Err = SensorValue[myGyro] + 900;
			moveRobot(-0.3*Err,0.3*Err);
		}
		moveRobot(0,0);

		// move
		Err = 0;
		nMotorEncoder[frontRight2] = 0;
		while(nMotorEncoder[frontRight2] < 800 && SensorValue[frontLim] > 1700)
		{
			Err = SensorValue[myGyro] + 900;
			moveRobot(50 - 0.5*Err,50 + 0.5*Err);
		}
	}
	else
	{
		// turn
		while(SensorValue[myGyro] < 600)
		{
			moveRobot(60,-60);
		}
		moveRobot(0,0);
		Err = 0;
		clearTimer(T1);
		while(time1(T1) < 1000)
		{
			Err = SensorValue[myGyro] - 900;
			moveRobot(-0.3*Err,0.3*Err);
		}
		moveRobot(0,0);

		// move
		Err = 0;
		nMotorEncoder[frontRight2] = 0;
		while(nMotorEncoder[frontRight2] < 800 && SensorValue[frontLim2] > 1700)
		{
			Err = SensorValue[myGyro] - 900;
			moveRobot(50 - 0.5*Err,50 + 0.5*Err);
		}
	}
	moveRobot(0,0);

	// brake
	clearTimer(T2);
	while(time1(T2) < 100)
	{
		moveRobot(-50,-50);
	}
	moveRobot(0,0);

	// lower the mobile goal intake, and lower the claws to the eating position while turning roller on to eat
	clearTimer(T1);
	while(time1(T1) < 1000)
	{
		if(time1(T1) < 700)
		{
			motorReq[MobGoalntake] = -127;
		}
		turnRollerToEat();
		moveClawsTo(1000);
	}
	moveClawsWith(0);
	motorReq[rollerMotor] = 30;
	motorReq[MobGoalntake] = 0;

	//clearTimer(T1);
	//while(time1(T1)<1000)
	//{
	//	motorReq[rollerMotor] = 30;
	//	if(SensorValue[clawsPot] < 2300){moveClawsTo(3300);motorReq[rollerMotor] = 30;}
	//	else{moveClawsWith(0);}
	//}

	/////////////////////////////////////////////////////////////////////////////////////// Getting the second mobile goal
	Err = 0;
	if(Blue)
	{
		// BLUE : turn to 1200* while moving claws up
		clearTimer(T1);
		while(time1(T1) < 1000)
		{
			//if(time1(T1) < 300)
			//{
			//	motorReq[MobGoalntake] = -127;
			//}
			//else
			//{
			//	motorReq[MobGoalntake] = 0;
			//}
			if(SensorValue[clawsPot] < 2500)
			{
				moveClawsTo(3300);
			}
			else
			{
				moveClawsWith(0);
			}
			Err = SensorValue[myGyro] + 1200;
			moveRobot(-0.5*Err,+0.5*Err);
		}
		moveRobot(0,0);

		// BLUE : move forward tilted 1200* for 800~ while lowering moble goal intake
		nMotorEncoder[frontRight2] = 0;
		while(nMotorEncoder[frontRight2] < 800)
		{
			motorReq[rollerMotor] = 50;
			motorReq[MobGoalntake] = -30;
			Err = SensorValue[myGyro] + 1200;
			moveRobot(50 - 0.5*Err,50 + 0.5*Err);
		}
	}
	else
	{
		// RED : turn to 1000* while moving clawss up
		clearTimer(T1);
		while(time1(T1) < 1000)
		{
			motorReq[rollerMotor] = 30;
			if(SensorValue[clawsPot] < 2300){moveClawsTo(3300);motorReq[rollerMotor] = 30;}
			else{moveClawsWith(0);}

			if(time1(T1) < 500)
			{
				motorReq[MobGoalntake] = -127;
			}
			else
			{
				motorReq[MobGoalntake] = 0;
			}
			Err = SensorValue[myGyro] - 1200;
			moveRobot(-0.5*Err,+0.5*Err);
		}
		moveRobot(0,0);
		// RED : move forward tilted 1200* for 800~ while lowering moble goal intake
		nMotorEncoder[frontRight2] = 0;
		while(nMotorEncoder[frontRight2] < 800)
		{
			motorReq[MobGoalntake] = -30;
			Err = SensorValue[myGyro] - 1200;
			moveRobot(50 - 0.5*Err,50 + 0.5*Err);
		}
	}
	motorReq[MobGoalntake] = 0;
	moveRobot(0,0);

	// move up the mobile goal intake after eating the mobile goal
	clearTimer(T1);
	while(time1(T1) < 1500)
	{
		if(time1(T1)<200)
		{
			turnRollerToEat();
		}
		else
		{
			motorReq[rollerMotor] = 30;
		}
		motorReq[MobGoalntake] = 127;
	}
	motorReq[MobGoalntake] = 0;

	// Eject the fourth cone
	clearTimer(T1);
	while(time1(T1) < 500)
	{
		turnRollerToEject();
	}
	motorReq[rollerMotor] = 0;

	//////////////////////////////////////////////////////////////////////////////////////////// Getting Fifth Cone

	// turn to 950*, then move to 1000* for 20~ while claws are in mid position, to arrive to the cone
	IErr = 0;
	if(Blue)
	{
		clearTimer(T1);
		while(time1(T1) < 1000)
		{
			Err = SensorValue[myGyro] + 950;
			IErr = IErr + Err;
			moveRobot(-0.3*Err, 0.3*Err);
		}
		moveRobot(0,0);

		SensorValue[leftEnc] = 0;
		while(SensorValue[leftEnc] < 20)
		{
			moveClawsTo(1800);
			Err = SensorValue[myGyro] + 1000;
			IErr = IErr + Err;
			moveRobot(40 - 0.3*Err,60 + 0.3*Err);
			//moveRobot(60,0);
		}
	}
	else
	{
		clearTimer(T1);
		while(time1(T1) < 1000)
		{
			Err = SensorValue[myGyro] - 950;
			IErr = IErr + Err;
			moveRobot(-0.3*Err, 0.3*Err);
		}
		moveRobot(0,0);

		nMotorEncoder[frontRight2] = 0;
		while(nMotorEncoder[frontRight2] < 20)
		{
			moveClawsTo(1800);
			Err = SensorValue[myGyro] - 1000;
			IErr = IErr + Err;
			moveRobot(60 - 0.3*Err,40 + 0.3*Err);
			//moveRobot(60,0);
		}
	}
	moveRobot(0,0);

	// eat the fifth cone
	clearTimer(T1);
	while(time1(T1) < 1000)
	{
		moveClawsTo(1000);
		turnRollerToEat();
	}
	motorReq[rollerMotor] = 30;
	moveClawsWith(0);
	moveRobot(0,0);

	// move claws to up position
	IErrc = 0;
	clearTimer(T2);
	while(time1(T2) < 1000)
	{
		moveCraneTo(40);
		if(SensorValue[clawsPot] < 2500)
		{
			moveClawsTo(3300);
		}
		else
		{
			moveClawsWith(0);
		}
	}

	// eject cone to score
	clearTimer(T2);
	while(time1(T2) < 500)
	{
		turnRollerToEject();
	}

	//////////////////////////////////////////////////////////////////////////////////////////// Getting Sixth Cone

	if(Blue)
	{
		// BLUE : move claws to mid, lower crane, move foreward gyro PI 1100* for 150~ to arrive to the cone, all in parallel
		SensorValue[leftEnc] = 0;
		while(SensorValue[leftEnc] < 150)
		{
			if(SensorValue[leftEnc] > 100)
			{
				moveClawsTo(1800);
			}
			Err = SensorValue[myGyro] + 1100;
			IErr = IErr + Err;
			moveRobot(60 - 0.5*Err - 0.0001*IErr,30 + 0.5*Err+0.0001*IErr);
			//moveRobot(60,0);
			if(SensorValue[craneEnc] > 10)
			{
				moveCraneWith(-127);
			}
			else
			{
				moveCraneWith(0);
			}
		}
		moveRobot(0,0);

		// BLUE : lower crane, move claws to reating position and turn roller on to eat the cone
		clearTimer(T2);
		while(time1(T2) < 1000)
		{
			if(SensorValue[craneEnc] > 10)
			{
				moveCraneWith(-127);
			}
			else
			{
				moveCraneWith(0);
			}
			//moveCraneTo(0);
			moveClawsTo(1000);
			turnRollerToEat();
		}
		motorReq[rollerMotor] = 30;
	}
	else
	{
		// RED : move claws to mid, lower crane, move foreward gyro PI 1100* for 180~ to arrive to the cone, all in parallel
		nMotorEncoder[frontRight2] = 0;
		while(nMotorEncoder[frontRight2] < 180)
		{
			if(nMotorEncoder[frontRight2] > 100){
				moveClawsTo(1800);
			}
			Err = SensorValue[myGyro] - 1100;
			IErr = IErr + Err;
			moveRobot(60 - 0.5*Err - 0.0001*IErr,30 + 0.5*Err+0.0001*IErr);
			//moveRobot(60,0);
			moveClawsTo(1800);
			if(SensorValue[craneEnc] > 10)
			{
				moveCraneWith(-127);
			}
			else
			{
				moveCraneWith(0);
			}

		}
		moveRobot(0,0);

		// RED : lower crane, move claws to reating position and turn roller on to eat the cone
		clearTimer(T2);
		while(time1(T2) < 1000)
		{
			moveCraneTo(0);
			turnRollerToEat();
		}
		motorReq[rollerMotor] = 30;
	}

	//////////////////////////////////////////////////////////////////////////////////////// Scoring Second Mobile Goal

	if(Blue)
	{
		// BLUE : move backwards tilted 1100* for 1500~ while holding crane to 100~ and claws to up position
		nMotorEncoder[frontRight2] = 0;
		clearTimer(T1);
		while(nMotorEncoder[frontRight2] > -1500)
		{
			Err = SensorValue[myGyro] + 1100;
			moveRobot(-50 - 0.3*Err,-50 + 0.3*Err);
			moveCraneTo(100);
			if(SensorValue[clawsPot] < 2500)
			{
				moveClawsTo(3300);
			}
			else
			{
				moveClawsWith(0);
			}
		}
		moveRobot(0,0);

		// BLUE : move backwards tilted 900* until detection of white line with back sensor, while ejecting cone
		Err = 0;
		IErrc = 0;
		nMotorEncoder[frontRight2] = 0;
		while(SensorValue[backLim] > 1800)
		{
			turnRollerToEject();
			Err = SensorValue[myGyro] + 900;
			moveRobot(-50 - 0.3*Err,-50 + 0.3*Err);
		}
		moveRobot(0,0);

		// BLUE : turn to score (perpendicular to the starting bar)
		clearTimer(T1);
		while(time1(T1) < 1000)
		{
			Err = SensorValue[myGyro] + 2250;
			moveRobot(-0.3*Err,0.3*Err);
		}
		moveRobot(0,0);

		// BLUE : lower the mobile goal intake to score, then move backwards
		clearTimer(T1);
		while(time1(T1)< 600)
		{
			motorReq[MobGoalntake] = -127;
			moveRobot(50,50);
		}
		motorReq[MobGoalntake] = 0;
		moveRobot(-50,-50);
	}
	else
	{
		// RED : move backwards tilted 1100* for 1500~ while holding crane to 100~ and claws to up position
		nMotorEncoder[frontRight2] = 0;
		clearTimer(T1);
		while(nMotorEncoder[frontRight2] > -1500)
		{
			moveCraneTo(100);
			if(SensorValue[clawsPot] < 2500)
			{
				moveClawsTo(3300);
			}
			else
			{
				moveClawsWith(0);
			}
			Err = SensorValue[myGyro] - 1100;
			moveRobot(-50 - 0.3*Err,-50 + 0.3*Err);
		}
		moveRobot(0,0);

		// RED : move backwards tilted 900* until detection of white line with back sensor, while ejecting cone
		Err = 0;
		nMotorEncoder[frontRight2] = 0;
		while(SensorValue[backLim] > 1800)
		{
			turnRollerToEject();
			Err = SensorValue[myGyro] - 900;
			moveRobot(-50 - 0.3*Err,-50 + 0.3*Err);
		}
		moveRobot(0,0);

		// RED : turn to score (perpendicular to the starting bar)
		clearTimer(T1);
		while(time1(T1) < 1000)
		{
			Err = SensorValue[myGyro] - 2250;
			moveRobot(-0.3*Err,0.3*Err);
		}
		moveRobot(0,0);

		// RED : lower the mobile goal intake to score, then move backwards
		clearTimer(T1);
		while(time1(T1)< 600)
		{
			motorReq[MobGoalntake] = -127;
			moveRobot(50,50);
		}
		motorReq[MobGoalntake] = 0;
		moveRobot(-50,-50);
	}

	// wait 0.5 secs before stopping the robot motion
	clearTimer(T1);
	while(time1(T1)<500){}
	moveRobot(0,0);

}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////					D R I V E R   C O N T R O L 					////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////

task usercontrol()
{
	startTask(MotorSlewRateTask);
	SensorValue[craneEnc] = 0;
	SensorValue[myGyro] = 0;
	int c = 0;
	while (true)
	{
		test2 = SensorValue[craneEnc];

		// TAREK : roller control
		if(vexRT[Btn6UXmtr2])
			turnRollerToEat();
		else if(vexRT[Btn6DXmtr2])
			turnRollerToEject();
		else
			motorReq[rollerMotor] = 0;

		// JAD : reset counter
		if(vexRT[Btn8L] && vexRT[Btn8R])
			conesCount = 0;

		// TAREK : hold the highest stack with the roller
		if(vexRT[Btn8RXmtr2])
		{
			postfield = false;
			holdStack = true;
			holdStackClicked = true;
		}

		// JAD : ?!
		if(vexRT[Btn7R] && !feederMode)
		{
			statGoalMode = true;
			goOnStat = true;
		}

		// JAD : mobile goal control
		if(vexRT[Btn6U] && !vexRT[Btn6D])
		{
			MobInUp = true;
			MobInDown = false;
		}
		if(vexRT[Btn6D] && !vexRT[Btn6U])
		{
			MobInUp = false;
			MobInDown = true;
		}
		if(!vexRT[Btn6D] && !vexRT[Btn6U])
		{
			MobInUp = false;
			MobInDown = false;
		}
		if(MobInUp && !MobInDown)
			motorReq[MobGoalntake] = 127;
		else if(!MobInUp && MobInDown)
			motorReq[MobGoalntake] = -127;
		else
			motorReq[MobGoalntake] = 0;

		// TAREK : go to pre_feeder mode
		if(vexRT[Btn7UXmtr2] && !feederMode)
		{
			prefeeder = true;
			postfield = false;
			prefield = false;
		}

		// TAREK : get claws back in case of any error (clawsRecv)
		if(vexRT[Btn8LXmtr2] && !fieldMode)
		{
			feederMode = false;
			prefeeder = false;
			fieldMode = false;
			clawsRecv = true;
		}

		// TAREK : crane control
		if(vexRT[Btn8UXmtr2] && !fieldMode)
		{
			holdStack = false;
			prefeeder = false;
			prefield = false;
			postfield = true;
		}
		if(vexRT[Btn8DXmtr2] && !fieldMode)
		{
			prefeeder = false;
			prefield = true;
			postfield = false;
		}

		// JAD : (go to/exit) feeder mode
		if(vexRT[Btn7U])
		{
			feederMode = true;
			goOnFeeder = true;
			fieldMode = false;
			goOnField = false;
			prefeeder = false;
			postfield = false;
			prefield = false;
		}
		if(vexRT[Btn7D])
		{
			feederMode = false;
			goOnFeeder = false;
		}

		// JAD : (go to/exit) field mode
		if(vexRT[Btn8U])
		{
			fieldMode = true;
			goOnField = true;
			clawsRecv = false;
			feederMode = false;
			goOnFeeder = false;
			prefield = false;
			prefeeder = false;
			postfield = false;
		}
		if(vexRT[Btn8D])
		{
			fieldMode = false;
			goOnField = false;
		}

		// get claws to up position in case of any error
		if(clawsRecv && !fieldMode)
		{
			if(SensorValue[clawsPot] < 3300)
			{
				moveClawsTo(3300);
			}
			else
			{
				moveClawsWith(0);
				clawsRecv = false;
			}
		}

		// hold the highest stack with the roller after the feeder mode
		if(holdStack)
		{
			if(SensorValue[craneEnc] > 200)
			{
				if(SensorValue[craneEnc] > craneVals[conesCount]){
					moveCraneTo(craneVals[conesCount]);
				}
				else
				{
					moveCraneWith(0);
				}
			}
		}

		// claws to mid and crane to cone level
		if(prefeeder)
		{
			moveCraneTo(130);
			moveClawsTo(2000);
		}

		// lower crane and move claws to up position
		if(prefield)
		{
			if(SensorValue[craneEnc] > 20)
				moveCraneTo(0);
			else
				moveCraneWith(0);

			if(SensorValue[clawsPot] < 2300)
				moveClawsTo(3300);
			else
				moveClawsWith(0);
		}

		// get crane high to 8U
		if(postfield)
		{
			if(holdStackClicked)
				turnRollerToEject();
			else
				motorReq[rollerMotor] = 0;

			moveCraneTo(450);
			if(SensorValue[craneEnc] < 350)
				moveClawsTo(1800);
			if(SensorValue[craneEnc] > 350)
				if(SensorValue[clawsPot] < 2400)	moveClawsTo(3300);
			else	moveClawsWith(0);
		}

		///////////////////////////////////////////////////////////////////////////////////////// stationnary goal sequence
		if(statGoalMode)
		{
			statGoalMode = false;
			int a1 = 0;
			int b1 = 0;

			// step 0 : lower claws
			while(!vexRT[Btn5DXmtr2] && goOnStat)
			{
				if(vexRT[Btn8D]) // a way to exit this mode
				{
					goOnStat = false;
				}
				moveClawsTo(1800);
				if(SensorValue[craneEnc] > 10)
				{
					moveCraneWith(-127);
				}
				else
				{
					moveCraneWith(0);
				}

				// move access
				a1 = vexRT[Ch2];
				b1 = vexRT[Ch3];
				if(abs(a1) < 15){a1 = 0;}
				if(abs(b1) < 15){b1 = 0;}
				if(a1*b1 < 0){a1 = 3*a1/5;b1 = 3*b1/5;}
				moveRobot(a1,b1);
				delay(10);
			}

			// step 1 : claws down and roller on
			while(!vexRT[Btn5UXmtr2] && goOnStat)
			{
				if(vexRT[Btn8D])
				{
					goOnStat = false;
				}
				moveClawsTo(1000);
				turnRollerToEat();
				if(SensorValue[craneEnc] > 5)
				{
					moveCraneWith(-127);
				}
				else
				{
					moveCraneWith(0);
				}
				a1 = vexRT[Ch2];
				b1 = vexRT[Ch3];
				if(abs(a1) < 15){a1 = 0;}
				if(abs(b1) < 15){b1 = 0;}
				if(a1*b1 < 0){a1 = 3*a1/5;b1 = 3*b1/5;}
				moveRobot(a1,b1);
				delay(10);
			}

			// step 2 : move crane up and move claws up to 2400~
			while(!vexRT[Btn5DXmtr2] && goOnStat)
			{
				if(vexRT[Btn8D])
				{
					goOnStat = false;
				}
				moveClawsTo(2400);
				motorReq[rollerMotor] = 30;
				moveCraneTo(craneValsStatH[statCount]);
				a1 = vexRT[Ch2];
				b1 = vexRT[Ch3];
				if(abs(a1) < 15){a1 = 0;}
				if(abs(b1) < 15){b1 = 0;}
				if(a1*b1 < 0){a1 = 3*a1/5;b1 = 3*b1/5;}
				moveRobot(a1,b1);
				delay(10);
			}

			// step 3 : lower crane to put cone
			while(!vexRT[Btn5UXmtr2] && goOnStat)
			{
				if(vexRT[Btn8D])
				{
					goOnStat = false;
				}
				moveClawsTo(2400);
				motorReq[rollerMotor] = 30;
				moveCraneTo(craneValsStat[statCount]);
				a1 = vexRT[Ch2];
				b1 = vexRT[Ch3];
				if(abs(a1) < 15){a1 = 0;}
				if(abs(b1) < 15){b1 = 0;}
				if(a1*b1 < 0){a1 = 3*a1/5;b1 = 3*b1/5;}
				moveRobot(a1,b1);
				delay(10);
			}

			// step 4 : eject cone then move crane up
			clearTimer(T1);
			clearTimer(T2);
			while(!vexRT[Btn5DXmtr2] && goOnStat)
			{
				if(vexRT[Btn8D])
				{
					goOnStat = false;
				}
				moveClawsTo(2400);
				turnRollerToEject();
				if(time1(T2) < 500)
				{
					moveCraneTo(craneValsStat[statCount]);
				}
				else
				{
					moveCraneTo(craneValsStatH[statCount]);
				}
				a1 = vexRT[Ch2];
				b1 = vexRT[Ch3];
				if(abs(a1) < 15){a1 = 0;}
				if(abs(b1) < 15){b1 = 0;}
				if(a1*b1 < 0){a1 = 3*a1/5;b1 = 3*b1/5;}
				moveRobot(a1,b1);
				delay(10);
			}

			// step 5 : move claws up and crane down
			while(!vexRT[Btn5UXmtr2] && goOnStat)
			{
				if(vexRT[Btn8D])
				{
					goOnStat = false;
				}
				if(SensorValue[clawsPot] < 2700)
				{
					moveClawsTo(3300);
				}
				else
				{
					moveClawsWith(0);
					if(SensorValue[craneEnc] > 10)
					{
						moveCraneTo(0);
					}
					else
					{
						moveCraneWith(0);
					}
				}
				a1 = vexRT[Ch2];
				b1 = vexRT[Ch3];
				if(abs(a1) < 15){a1 = 0;}
				if(abs(b1) < 15){b1 = 0;}
				if(a1*b1 < 0){a1 = 3*a1/5;b1 = 3*b1/5;}
				moveRobot(a1,b1);
				delay(10);
			}

			// stationnary goal counter control
			while(true && goOnStat)
			{
				moveRobot(0,0);
				if(vexRT[Btn5U])
				{
					statCount = statCount + 1;
					break;
				}
				if(vexRT[Btn5D])
				{
					break;
				}
			}
			moveCraneWith(0);
		}

		//////////////////////////////////////////////////////////////////////////////////////////// field mode sequence
		if(fieldMode)
		{
			int a1 = 0;
			int b1 = 0;
			bool man_aut;

			if(conesCount > 0)
			{
				// step 0 : lower crane and move claws to mid
				IErr = 0;
				while(!vexRT[Btn5DXmtr2] && goOnField)
				{
					if(vexRT[Btn8D])
					{
						goOnField = false;
						fieldMode = false;
					}
					moveClawsTo(1800);
					if(man_aut)
					{
						if(SensorValue[craneEnc] > 10)
						{moveCraneTo(0);}
						else
						{
							moveCraneWith(0);
						}
					}
					else
					{
						moveCraneWith(-127);
					}
					if(vexRT[Ch2Xmtr2] < -10)
					{
						man_aut = false;
					}
					else
					{
						man_aut = true;
					}

					// move access
					a1 = vexRT[Ch2];
					b1 = vexRT[Ch3];
					if(abs(a1) < 15){a1 = 0;}
					if(abs(b1) < 15){b1 = 0;}
					if(a1*b1 < 0){a1 = 3*a1/5;b1 = 3*b1/5;}
					moveRobot(a1,b1);
					//CraneEncVal = SensorValue[CraneEnc];
					delay(10);
				}
				moveRobot(0,0);


				//step 1 : claws down + Roller eating
				IErr = 0;
				while(!vexRT[Btn5UXmtr2] && goOnField)
				{
					if(vexRT[Btn8D])
					{
						goOnField = false;
						fieldMode = false;
					}
					moveClawsTo(1000);
					if(vexRT[Ch2Xmtr2] < -10)
					{
						man_aut = false;
					}
					else
					{
						man_aut = true;
					}
					if(man_aut)
					{
						if(SensorValue[craneEnc] > 10)
						{moveCraneTo(0);}
						else
						{
							moveCraneWith(0);
						}
					}
					else
					{
						moveCraneWith(-127);
					}
					turnRollerToEat();
					a1 = vexRT[Ch2];
					b1 = vexRT[Ch3];
					if(abs(a1) < 15){a1 = 0;}
					if(abs(b1) < 15){b1 = 0;}
					if(a1*b1 < 0){a1 = 3*a1/5;b1 = 3*b1/5;}
					moveRobot(a1,b1);
					delay(10);
				}

				// step 2 : go back to mid position
				IErr = 0;
				while(!vexRT[Btn5DXmtr2] && goOnField)
				{
					if(vexRT[Btn8D])
					{
						goOnField = false;
						fieldMode = false;
					}
					motorReq[rollerMotor] = 30;
					moveClawsTo(1700);
					a1 = vexRT[Ch2];
					b1 = vexRT[Ch3];
					if(abs(a1) < 15){a1 = 0;}
					if(abs(b1) < 15){b1 = 0;}
					if(a1*b1 < 0){a1 = 3*a1/5;b1 = 3*b1/5;}
					moveRobot(a1,b1);

					delay(10);
				}

				// step 3 : moving crane to desired position
				IErr = 0;
				while(!vexRT[Btn5UXmtr2] && goOnField)
				{
					if(vexRT[Btn8D])
					{
						goOnField = false;
						fieldMode = false;
					}
					moveClawsTo(1800);
					moveCraneTo(craneValsH[conesCount]);
					a1 = vexRT[Ch2];
					b1 = vexRT[Ch3];
					if(abs(a1) < 15){a1 = 0;}
					if(abs(b1) < 15){b1 = 0;}
					if(a1*b1 < 0){a1 = 3*a1/5;b1 = 3*b1/5;}
					moveRobot(a1,b1);

					delay(10);
				}

				//step 4 : move claws to up position
				c = 0;
				while(!vexRT[Btn5DXmtr2] && goOnField)
				{
					if(vexRT[Btn8D])
					{
						goOnField = false;
						fieldMode = false;
					}
					moveCraneTo(craneValsH[conesCount]);
					if(SensorValue[clawsPot] < 2300){moveClawsTo(3300);motorReq[rollerMotor] = 30;}
					else{moveClawsWith(0);}
					a1 = vexRT[Ch2];
					b1 = vexRT[Ch3];
					if(abs(a1) < 15){a1 = 0;}
					if(abs(b1) < 15){b1 = 0;}
					if(a1*b1 < 0){a1 = 3*a1/5;b1 = 3*b1/5;}
					moveRobot(a1,b1);

					delay(10);
				}

				// step 5 : go down to the desired low crane position (last cone level)
				IErr = 0;
				while(!vexRT[Btn5UXmtr2] && goOnField)
				{
					if(vexRT[Btn8D])
					{
						goOnField = false;
						fieldMode = false;
					}
					if(SensorValue[craneEnc] > craneVals[conesCount])
					{
						moveCraneTo(craneVals[conesCount]);
					}
					else
					{
						moveCraneWith(0);
					}
					a1 = vexRT[Ch2];
					b1 = vexRT[Ch3];
					if(abs(a1) < 15){a1 = 0;}
					if(abs(b1) < 15){b1 = 0;}
					if(a1*b1 < 0){a1 = 3*a1/5;b1 = 3*b1/5;}
					moveRobot(a1,b1);

					delay(10);
				}
				// step 6 : eject cone
				IErr = 0;
				clearTimer(T1);
				while(!vexRT[Btn5DXmtr2] && goOnField)
				{
					if(vexRT[Btn8D])
					{
						goOnField = false;
						fieldMode = false;
					}
					if(time1(T1) < 500){
						turnRollerToEject();
					}
					else
					{
						turnRollerToEject();
						moveCraneTo(craneValsH[conesCount]);
					}
					a1 = vexRT[Ch2];
					b1 = vexRT[Ch3];
					if(abs(a1) < 15){a1 = 0;}
					if(abs(b1) < 15){b1 = 0;}
					if(a1*b1 < 0){a1 = 3*a1/5;b1 = 3*b1/5;}
					moveRobot(a1,b1);

					delay(10);
				}
				motorReq[rollerMotor] = 0;

				// step 7 : claws back to mid pos and move crane Down
				IErr = 0;
				while(!vexRT[Btn5UXmtr2] && goOnField)
				{
					if(vexRT[Btn8D])
					{
						goOnField = false;
						fieldMode = false;
					}
					moveClawsTo(1800);
					moveCraneTo(0);
					a1 = vexRT[Ch2];
					b1 = vexRT[Ch3];
					if(abs(a1) < 15){a1 = 0;}
					if(abs(b1) < 15){b1 = 0;}
					if(a1*b1 < 0){a1 = 3*a1/5;b1 = 3*b1/5;}
					moveRobot(a1,b1);

					delay(10);
				}
			}

			// special case for the first cone
			if(conesCount == 0)
			{
				// step 0 : claws to mid and crane down
				IErr = 0;
				while(!vexRT[Btn5DXmtr2] && goOnField)
				{
					if(vexRT[Btn8D])
					{
						goOnField = false;
						fieldMode = false;
					}
					moveClawsTo(1800);
					if(man_aut)
					{
						if(SensorValue[craneEnc] > 10)
						{moveCraneTo(0);}
						else
						{
							moveCraneWith(0);
						}
					}
					else
					{
						moveCraneWith(-127);
					}
					if(vexRT[Ch2Xmtr2] < -10)
					{
						man_aut = false;
					}
					else
					{
						man_aut = true;
					}
					a1 = vexRT[Ch2];
					b1 = vexRT[Ch3];
					if(abs(a1) < 15){a1 = 0;}
					if(abs(b1) < 15){b1 = 0;}
					if(a1*b1 < 0){a1 = 3*a1/5;b1 = 3*b1/5;}
					moveRobot(a1,b1);
					//CraneEncVal = SensorValue[CraneEnc];
					delay(10);
				}
				moveRobot(0,0);

				// step 1 : claws down + Roller eating
				IErr = 0;
				while(!vexRT[Btn5UXmtr2] && goOnField)
				{
					if(vexRT[Btn8D])
					{
						goOnField = false;
						fieldMode = false;
					}
					moveClawsTo(1000);
					turnRollerToEat();
					if(vexRT[Ch2Xmtr2] < -20){
						moveCraneWith(vexRT[Ch2Xmtr2]);
					}
					else
					{
						moveCraneWith(0);
					}
					a1 = vexRT[Ch2];
					b1 = vexRT[Ch3];
					if(abs(a1) < 15){a1 = 0;}
					if(abs(b1) < 15){b1 = 0;}
					if(a1*b1 < 0){a1 = 3*a1/5;b1 = 3*b1/5;}
					moveRobot(a1,b1);

					delay(10);
				}

				// step 2 : claws up
				IErr = 0;
				while(!vexRT[Btn5DXmtr2] && goOnField)
				{
					if(vexRT[Btn8D])
					{
						goOnField = false;
						fieldMode = false;
					}
					if(SensorValue[clawsPot] < 2300){moveClawsTo(3300);motorReq[rollerMotor] = 30;}
					else{moveClawsWith(0);}
					if(vexRT[Ch2Xmtr2] < -10){
						moveCraneWith(-127);
					}
					else
					{
						moveCraneWith(0);
					}
					a1 = vexRT[Ch2];
					b1 = vexRT[Ch3];
					if(abs(a1) < 15){a1 = 0;}
					if(abs(b1) < 15){b1 = 0;}
					if(a1*b1 < 0){a1 = 3*a1/5;b1 = 3*b1/5;}
					moveRobot(a1,b1);

					delay(10);
				}

				// step 3 : eject cone
				IErr = 0;
				clearTimer(T1);
				while(!vexRT[Btn5UXmtr2] && goOnField)
				{
					if(vexRT[Btn8D])
					{
						goOnField = false;
						fieldMode = false;
					}
					if(time1(T1) < 500){
						turnRollerToEject();
					}
					else
					{
						motorReq[rollerMotor] = 0;
					}
					if(vexRT[Ch2Xmtr2] < -10){
						moveCraneWith(-127);
					}
					else
					{
						moveCraneWith(0);
					}
					a1 = vexRT[Ch2];
					b1 = vexRT[Ch3];
					if(abs(a1) < 15){a1 = 0;}
					if(abs(b1) < 15){b1 = 0;}
					if(a1*b1 < 0){a1 = 3*a1/5;b1 = 3*b1/5;}
					moveRobot(a1,b1);
					delay(10);

				}
				motorReq[rollerMotor] = 0;
			}
			moveCraneWith(0);

			// move access, mobile goal control access, increment counter/break access
			IErr = 0;
			while(true && goOnField)
			{
				if(vexRT[Btn6U])
				{
					motorReq[MobGoalntake] = 127;
				}
				else if(vexRT[Btn6D])
				{
					motorReq[MobGoalntake] = -127;
				}
				else
				{
					motorReq[MobGoalntake] = 0;
				}
				a1 = vexRT[Ch2];
				b1 = vexRT[Ch3];
				if(abs(a1) < 15){a1 = 0;}
				if(abs(b1) < 15){b1 = 0;}
				if(a1*b1 < 0){a1 = 3*a1/5;b1 = 3*b1/5;}
				moveRobot(a1,b1);
				if(vexRT[Btn8D])
				{
					goOnField = false;
					fieldMode = false;
					break;
				}
				if(conesCount > 0){
					moveClawsTo(1800);
				}
				//fieldMode = false;
				if(vexRT[Btn5U])
				{
					if(conesCount < 9)
					{
						conesCount = conesCount + 1;
					}
					break;
				}
				if(vexRT[Btn5D])
				{
					break;
				}
			}
		}
		else
		{
			//////////////////////////////////////////////////////////////////////////////////////////// feeder mode sequence
			if(feederMode)
			{
				int a1 = 0;
				int b1 = 0;
				// step 0 : crane down to zero level, roller on to eat cone, claws in feeder position (almost mid)
				while(!vexRT[Btn5DXmtr2] && goOnFeeder)
				{
					if(vexRT[Btn7D])
					{
						goOnFeeder = false;
						feederMode = false;
					}
					if(vexRT[Btn7L] || vexRT[Btn7R])
					{
						goOnFeeder = false;
						feederMode = false;
						prefeeder = true;
					}
					moveClawsTo(2000);
					moveCraneTo(0);
					turnRollerToEat();
					//a1 = vexRT[Ch2];
					//b1 = vexRT[Ch3];
					//if(abs(a1) < 15){a1 = 0;}
					//if(abs(b1) < 15){b1 = 0;}
					//if(a1*b1 < 0){a1 = 3*a1/5;b1 = 3*b1/5;}
					moveRobot(a1,b1);
					//CraneEncVal = SensorValue[CraneEnc];
					delay(10);
				}

				// step 1 : turn off roller, crane up to HVFeeder
				motorReq[rollerMotor] = 0;
				moveClawsWith(0);
				IErr = 0;
				while(!vexRT[Btn5UXmtr2] && goOnFeeder)
				{
					motorReq[rollerMotor] = 30;
					if(vexRT[Btn7D])
					{
						goOnFeeder = false;
						feederMode = false;
					}
					if(vexRT[Btn7L] || vexRT[Btn7R])
					{
						goOnFeeder = false;
						feederMode = false;
						prefeeder = true;
					}
					moveClawsTo(2000);
					if(SensorValue[craneEnc] < craneValsHFeeder[conesCount])
					{
						moveCraneTo(craneValsHFeeder[conesCount]);
					}
					else
					{
						moveCraneWith(0);
					}
					delay(10);
				}
				moveCraneWith(0);
				// step 2 : claws back to up position
				IErr = 0;
				while(!vexRT[Btn5DXmtr2] && goOnFeeder)
				{
					if(vexRT[Btn7D])
					{
						goOnFeeder = false;
						feederMode = false;
					}
					if(vexRT[Btn7L] || vexRT[Btn7R])
					{
						goOnFeeder = false;
						feederMode = false;
						prefeeder = true;
					}

					if(SensorValue[craneEnc] < craneValsHFeeder[conesCount])
					{
						moveCraneTo(craneValsHFeeder[conesCount]);
					}
					else
					{
						moveCraneWith(0);
					}
					if(SensorValue[clawsPot] < 2300){moveClawsTo(3300);motorReq[rollerMotor] = 30;}
					else{moveClawsWith(0);}
					delay(10);
				}
				// step 3 : crane go down to desired position
				moveCraneWith(0);
				IErr = 0;
				while(!vexRT[Btn5UXmtr2] && goOnFeeder)
				{
					if(vexRT[Btn7D])
					{
						goOnFeeder = false;
						feederMode = false;
					}
					if(vexRT[Btn7L] || vexRT[Btn7R])
					{
						goOnFeeder = false;
						feederMode = false;
						prefeeder = true;
					}
					if(SensorValue[craneEnc] > craneVals[conesCount])
					{
						moveCraneTo(craneVals[conesCount]);
					}
					else
					{
						moveCraneWith(0);
					}
					delay(10);
				}
				// step 4 : eject cone + go to HVFeeder
				clearTimer(T1);
				IErr = 0;
				while(!vexRT[Btn5DXmtr2] && goOnFeeder)
				{
					if(vexRT[Btn7D])
					{
						goOnFeeder = false;
						feederMode = false;
					}
					if(vexRT[Btn7L] || vexRT[Btn7R])
					{
						turnRollerToEject();
						goOnFeeder = false;
						feederMode = false;
						prefeeder = true;
					}
					if(time1(T1) < 700){
						turnRollerToEject();
					}
					else
					{
						turnRollerToEject();
						if(SensorValue[craneEnc] < craneValsHFeeder[conesCount])
						{
							moveCraneTo(craneValsHFeeder[conesCount]);
						}
						else
						{
							moveCraneWith(0);
						}
					}
					delay(10);
				}
				// step 5 : move claws to feeder position while crane still up in HFeeder
				IErr = 0;
				while(!vexRT[Btn5UXmtr2] && goOnFeeder)
				{
					if(vexRT[Btn7D])
					{
						goOnFeeder = false;
						feederMode = false;
					}
					if(vexRT[Btn7L] || vexRT[Btn7R])
					{
						goOnFeeder = false;
						feederMode = false;
						prefeeder = true;
					}
					moveClawsTo(2000);
					if(SensorValue[craneEnc] < craneValsHFeeder[conesCount])
					{
						moveCraneTo(craneValsHFeeder[conesCount]);
					}
					else
					{
						moveCraneWith(0);
					}
					delay(10);
				}
				IErr = 0;

				// move access, mobile goal access, claws to mid, counter access
				while(true && goOnFeeder)
				{
					if(vexRT[Btn6U])
					{
						motorReq[MobGoalntake] = 127;
					}
					else if(vexRT[Btn6D])
					{
						motorReq[MobGoalntake] = -127;
					}
					else
					{
						motorReq[MobGoalntake] = 0;
					}
					a1 = vexRT[Ch2];
					b1 = vexRT[Ch3];
					if(abs(a1) < 15){a1 = 0;}
					if(abs(b1) < 15){b1 = 0;}
					if(a1*b1 < 0){a1 = 3*a1/5;b1 = 3*b1/5;}
					moveRobot(a1,b1);

					moveClawsTo(1800);
					//fieldMode = false;
					if(vexRT[Btn7D])
					{
						goOnFeeder = false;
						feederMode = false;
						break;
					}
					if(vexRT[Btn7L] || vexRT[Btn7R])
					{
						goOnFeeder = false;
						feederMode = false;
						prefeeder = true;
						break;
					}
					if(vexRT[Btn5U])
					{
						if(conesCount < 9)
						{
							conesCount = conesCount + 1;
						}
						break;
					}
					if(vexRT[Btn5D])
					{
						break;
					}
				}
			}
		}

		int a = vexRT[Ch2];
		int b = vexRT[Ch3];
		if(abs(a) < 15){a = 0;}
		if(abs(b) < 15){b = 0;}
		if(a*b < 0){a = 3*a/5;b = 3*b/5;}

		motorReq[frontLeftExp] = b;
		motorReq[backLeft] = b;
		motorReq[frontRight1] = a;
		motorReq[frontRight2] = a;
		motorReq[backRight] = a;

	}
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////


void moveClawsTo(int clawsTar)
{
	int Err = SensorValue[clawsPot] - clawsTar;
	moveClawsWith(0.1*Err);
}
void moveClawsWith(int speed)
{
	motorReq[rightClaws] = motorReq[leftClaws] = speed;
}
void moveCraneWith(int speed)
{
	motorReq[craneMotorsExp]= speed;
}
void moveCraneTo(int craneTar)
{
	int Errcr = -SensorValue[craneEnc] + craneTar;
	moveCraneWith(1.2*Errcr + 0.00001*IErrc);
	if(abs(1.2*Errcr + 0.00001*IErrc) < MAX_CMD)
	{
		IErrc = IErrc + Errcr;
	}
}
void moveRobot(int RSpeed, int LSpeed)
{
	motorReq[frontLeftExp] = LSpeed;
	motorReq[backLeft] = LSpeed;
	motorReq[frontRight1] = RSpeed;
	motorReq[frontRight2] = RSpeed;
	motorReq[backRight] = RSpeed;
}
void turnRollerToEat()
{
	motorReq[rollerMotor] = 127;
}
void turnRollerToEject()
{
	motorReq[rollerMotor] = -127;
}
