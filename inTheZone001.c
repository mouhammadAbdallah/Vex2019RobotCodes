#pragma config(Sensor, in7,    cranePot,       sensorPotentiometer)
#pragma config(Sensor, in8,    myPot,          sensorPotentiometer)
#pragma config(Sensor, dgtl1,  solenoid1,      sensorDigitalOut)
#pragma config(Motor,  port1,           frontRight,    tmotorVex393HighSpeed_HBridge, openLoop)
#pragma config(Motor,  port2,           backLeft,      tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port3,           backRight,     tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           leftMI,        tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           rightMI,       tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port6,           LLCrane,       tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port7,           RLCrane,       tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           LHCrane,       tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port9,           RHCrane,       tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port10,          frontLeft,     tmotorVex393HighSpeed_HBridge, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*        Description: Competition template for VEX EDR                      */
/*                                                                           */
/*---------------------------------------------------------------------------*/

// This code is for the VEX cortex platform
#pragma platform(VEX2)

// Select Download method as "competition"
#pragma competitionControl(Competition)

//Main competition background code...do not modify!
#include "Vex_Competition_Includes.c"

/*---------------------------------------------------------------------------*/
/*                          Pre-Autonomous Functions                         */
/*                                                                           */
/*  You may want to perform some actions before the competition starts.      */
/*  Do them in the following function.  You must return from this function   */
/*  or the autonomous and usercontrol tasks will not be started.  This       */
/*  function is only called once after the cortex has been powered on and    */
/*  not every time that the robot is disabled.                               */
/*---------------------------------------------------------------------------*/

#define MOTOR_NUM               kNumbOfTotalMotors
#define MOTOR_MAX_VALUE         127
#define MOTOR_MIN_VALUE         (-127)
#define MOTOR_DEFAULT_SLEW_RATE 30      // Default will cause 375mS from full fwd to rev
#define MOTOR_FAST_SLEW_RATE    256     // essentially off
#define MOTOR_TASK_DELAY        15      // task 1/frequency in mS (about 66Hz)
#define MOTOR_DEADBAND          10

int motorReq[MOTOR_NUM];
int motorSlew[MOTOR_NUM];

void moveCraneUp(int speed);
void moveCraneDown();
task MotorSlewRateTask()
{
	int motorIndex;
	int motorTmp;


	// Initialize stuff
	for (motorIndex = 0; motorIndex < (signed)MOTOR_NUM; motorIndex++)
	{
		motorReq[motorIndex] = 0;
		motorSlew[motorIndex] = MOTOR_DEFAULT_SLEW_RATE;
	}

	// run task until stopped
	while (true)
	{
		// run loop for every motor
		for (motorIndex = 0; motorIndex < (signed)MOTOR_NUM; motorIndex++)
		{
			// So we don't keep accessing the internal storage
			motorTmp = motor[motorIndex];

			// Do we need to change the motor value ?
			if (motorTmp != motorReq[motorIndex])
			{
				// increasing motor value
				if (motorReq[motorIndex] > motorTmp)
				{
					motorTmp += motorSlew[motorIndex];
					// limit
					if (motorTmp > motorReq[motorIndex])
						motorTmp = motorReq[motorIndex];
				}

				// decreasing motor value
				if (motorReq[motorIndex] < motorTmp)
				{
					motorTmp -= motorSlew[motorIndex];
					// limit
					if (motorTmp < motorReq[motorIndex])
						motorTmp = motorReq[motorIndex];
				}

				// finally set motor
				motor[motorIndex] = motorTmp;
			}
		}

		// Wait approx the speed of motor update over the spi bus
		wait1Msec(MOTOR_TASK_DELAY);
	}
}

void pre_auton()
{
  bStopTasksBetweenModes = true;

}


task autonomous()
{

}


int potVal = SensorValue[myPot];
int cranePotVal = SensorValue[cranePot];
task usercontrol()
{


  	startTask(MotorSlewRateTask);
  	while(true)
	{
		cranePotVal = SensorValue[cranePot];
			potVal = SensorValue[myPot];
			if(vexRT[Btn7U])
				{
					while(cranePotVal > 0)
						{
						moveCraneUp(127);
						cranePotVal = SensorValue[cranePot];
					//	}
					//	motorReq[LLCrane] =  motorReq[LHCrane] = motorReq[RLCrane] = motorReq[RHCrane] = 20;
					//	delay(1000);
					//	motorReq[LLCrane] =  motorReq[LHCrane] = motorReq[RLCrane] = motorReq[RHCrane] = 10;
			}

	moveCraneDown();
				}
				if(vexRT[Btn7D])
				{
				while(cranePotVal < 2400)
						{
						moveCraneUp(-20);
						cranePotVal = SensorValue[cranePot];
					//	}
					//	motorReq[LLCrane] =  motorReq[LHCrane] = motorReq[RLCrane] = motorReq[RHCrane] = 20;
					//	delay(1000);
					//	motorReq[LLCrane] =  motorReq[LHCrane] = motorReq[RLCrane] = motorReq[RHCrane] = 10;
			}
			moveCraneDown();
				}

			if(vexRT[Btn8U])
				{
				while(potVal > 950)
					{
						motorReq[leftMI] = motorReq[rightMI] = 100;
						potVal = SensorValue[myPot];
					}
					motorReq[leftMI] = motorReq[rightMI] = 0;
				}
				if(vexRT[Btn5U])
					{
						SensorValue[solenoid1] = 1;
					}
				if(vexRT[Btn5D])
					{
						SensorValue[solenoid1] = 0;
					}

				if(vexRT[Btn8D])
				{
				while(potVal < 2200)
					{
						motorReq[leftMI] = motorReq[rightMI] = -100;
						potVal = SensorValue[myPot];
					}
					motorReq[leftMI] = motorReq[rightMI] = 0;
				}
			int a = vexRT[Ch2];
			int b = vexRT[Ch3];
			if(abs(a) < 15){a = 0;}
			if(abs(b) < 15){b = 0;}
			if(a*b < 0){a = 3*a/5;b = 3*b/5;}
			motorReq[frontRight] = motorReq[backRight] = a;
			motorReq[frontLeft] = motorReq[backLeft] = b;
	}
}
void moveCraneUp(int speed)
{
		motorReq[LLCrane] = speed;
		motorReq[LHCrane] = speed;
		motorReq[RLCrane] = speed;
		motorReq[RHCrane] = speed;
}
void moveCraneDown()
{
	moveCraneUp(0);
}
