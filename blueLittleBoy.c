#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    lFLeft,         sensorLineFollower)
#pragma config(Sensor, in5,    lFRight,        sensorLineFollower)
#pragma config(Sensor, in6,    myGyro,         sensorGyro)
#pragma config(Sensor, dgtl1,  leftTouch,      sensorTouch)
#pragma config(Sensor, dgtl6,  encoderGolf,    sensorQuadEncoder)
#pragma config(Sensor, dgtl12, rightTouch,     sensorTouch)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           backLeft,      tmotorVex393HighSpeed_HBridge, openLoop, reversed)
#pragma config(Motor,  port2,           lowIntake,     tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port3,           frontLeft,     tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port4,           golfUP,        tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           frontRight,    tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           highIntake,    tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           golfDown,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          backRight,     tmotorVex393HighSpeed_HBridge, openLoop, reversed, encoderPort, I2C_1)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(0)
#pragma userControlDuration(60)

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!


#define MOTOR_NUM               kNumbOfTotalMotors
#define MOTOR_MAX_VALUE         127
#define MOTOR_MIN_VALUE         (-127)
#define MOTOR_DEFAULT_SLEW_RATE 30      // Default will cause 375mS from full fwd to rev
#define MOTOR_FAST_SLEW_RATE    256     // essentially off
#define MOTOR_TASK_DELAY        20      // task 1/frequency in mS (about 66Hz)
#define MOTOR_DEADBAND          10
#define MAX_CMD									127


void moveRobot(int LSpeed, int RSpeed);
void eatBall();
void invertCap();
void stopIntakes();
void ejectGolf();
void eatSecondBall();
void stopGolf();




int motorReq[MOTOR_NUM];
int motorSlew[MOTOR_NUM];


task MotorSlewRateTask()
{
	int motorIndex;
	int motorTmp;


	// Initialize stuff
	for (motorIndex = 0; motorIndex < (signed)MOTOR_NUM; motorIndex++)
	{
		motorReq[motorIndex] = 0;
		motorSlew[motorIndex] = MOTOR_DEFAULT_SLEW_RATE;
	}

	// run task until stopped
	while (true)
	{
		// run loop for every motor
		for (motorIndex = 0; motorIndex < (signed)MOTOR_NUM; motorIndex++)
		{
			// So we don't keep accessing the internal storage
			motorTmp = motor[motorIndex];

			// Do we need to change the motor value ?
			if (motorTmp != motorReq[motorIndex])
			{
				// increasing motor value
				if (motorReq[motorIndex] > motorTmp)
				{
					motorTmp += motorSlew[motorIndex];
					// limit
					if (motorTmp > motorReq[motorIndex])
						motorTmp = motorReq[motorIndex];
				}

				// decreasing motor value
				if (motorReq[motorIndex] < motorTmp)
				{
					motorTmp -= motorSlew[motorIndex];
					// limit
					if (motorTmp < motorReq[motorIndex])
						motorTmp = motorReq[motorIndex];
				}

				// finally set motor
				motor[motorIndex] = motorTmp;
			}
		}

		// Wait approx the speed of motor update over the spi bus
		wait1Msec(MOTOR_TASK_DELAY);
	}
}

int Err;
int IErr;
int robotEncoder;

void pre_auton()
{
	bStopTasksBetweenModes = true;

}



task autonomous()
{
	startTask(MotorSlewRateTask);

	IErr = 0;
	SensorValue[myGyro]=0;
	nMotorEncoder[backRight]=robotEncoder=0;
	//go to eat second ball from the fat man
	while(robotEncoder<280){
		robotEncoder=	nMotorEncoder[backRight];
		//eat second ball
		eatSecondBall();
		//go straight
		Err = SensorValue[myGyro];
		IErr = IErr + Err;
		moveRobot(60 + 0.6*Err+ 0.0001*IErr,60 - 0.6*Err - 0.0001*IErr);
	}
	//stop robot
	moveRobot(0,0);
	moveRobot(-40,-40);
	delay(50);
	moveRobot(0,0);
	delay(600);

	stopIntakes();

	//turn left 175 degree to golf the first,high flag
	while(SensorValue[myGyro] > -1600)
	{
		moveRobot(50,-50);
	}
	moveRobot(0,0);

	clearTimer(T1);
	while(time1(T1)<800)
	{
		Err = SensorValue[myGyro] + 1750;
		moveRobot(0.35*Err,-0.35*Err);
	}

	moveRobot(0,0);
	delay(50);


	//golf the first ball to the high flag
	clearTimer(T2);
	while(time1(T2)<1000){

		ejectGolf();
	}
	stopGolf();
	delay(50);




	//go straight then golf the second ball to the middle flag and eat ball from you
	eatBall();
	nMotorEncoder[backRight]=robotEncoder=0;
	IErr=0;
	while(robotEncoder<700){
		robotEncoder=	nMotorEncoder[backRight];
		Err = SensorValue[myGyro]+1750;
		IErr = IErr + Err;
		moveRobot(60 + 0.4*Err+ 0.0001*IErr,60 - 0.4*Err - 0.0001*IErr);
	}
	moveRobot(0,0);

	delay(50);
	clearTimer(T3);
	while(time1(T3)<1000){

		ejectGolf();
	}
	stopGolf();

	moveRobot(0,0);
	delay(50);

	stopIntakes();
	//go straight to turn the low flag and eat a ball by the way
	IErr=0;

	nMotorEncoder[backRight]=robotEncoder=0;
	clearTimer(T4);clearTimer(T1);
	while((time1(T4)<2000)	||(time1(T1)<2000)){
		Err = SensorValue[myGyro]+1800;
		IErr = IErr + Err;
		moveRobot(40 + 0.4*Err*0+ 0.0001*IErr*0,40 - 0.4*Err*0 - 0.0001*IErr*0);
	}
	moveRobot(0,0);
	delay(100);

	//go back to blue from the first flag post

	while(((SensorValue[lFLeft]>1000) &&( SensorValue[lFRight]>1000))){
		moveRobot(-40,-40);
	}
	stopIntakes();
	moveRobot(0,0);
	delay(50);

	//go straight little to turn right and invert the first cap
	nMotorEncoder[backRight]=robotEncoder=0;
	while(robotEncoder<90){
		robotEncoder=nMotorEncoder[backRight];
		moveRobot(40,40);
	}
	moveRobot(0,0);
	delay(50);

	//turn right 80 degree to invert the first cap
	SensorValue[myGyro]=0;
	while(SensorValue[myGyro] <800)
	{
		moveRobot(-50,+50);
	}
	moveRobot(0,0);

	//go back to setup the gyro where the robot is looking to the first cap
	clearTimer(T1);
	while(((SensorValue[leftTouch]!=1) ||( SensorValue[rightTouch]!=1))&&(time1(T1)<2000)){
		moveRobot(-70 ,-70 );
	}
	moveRobot(0,0);
	delay(50);

	//go straight to invert the cap and put it after lines
	SensorValue[myGyro]=0;
	IErr=0;
	robotEncoder=	nMotorEncoder[backRight]=0;
	invertCap();
	clearTimer(T3);
	while((robotEncoder<1200)&&(time1(T3)<5000)){
		if(robotEncoder>900)	stopIntakes();
		robotEncoder=	nMotorEncoder[backRight];
		Err = SensorValue[myGyro];
		IErr = IErr + Err;
		moveRobot(30 + 0.4*Err+ 0.0001*IErr,30 - 0.4*Err - 0.0001*IErr);
	}
	moveRobot(0,0);
	delay(50);

	//go back to setup the gyro after finishing the first cap
		IErr=0;
	clearTimer(T1);
	while(((SensorValue[leftTouch]!=1) ||( SensorValue[rightTouch]!=1))&&(time1(T1)<3000)){
		Err = SensorValue[myGyro];
		IErr = IErr + Err;
		moveRobot(-70 + 0.1*Err+ 0.0001*IErr,-70 -0.1*Err - 0.0001*IErr);
	}
	moveRobot(0,0);
	delay(50);



	//turn right 90 degree to get the second line
	while(SensorValue[myGyro] < 700)
	{
		moveRobot(-50,50);
	}
	moveRobot(0,0);
	clearTimer(T1);
	while(time1(T1)<900)
	{
		Err = SensorValue[myGyro] -900;
		moveRobot(0.4*Err,-0.4*Err);
	}
	moveRobot(0,0);
	delay(50);

	//go straight to touch the blue to get the second line
	nMotorEncoder[backRight]=robotEncoder=0;
	IErr=0;

	while((SensorValue[lFLeft]>1000) ||( SensorValue[lFRight]>1000)){
		robotEncoder=	nMotorEncoder[backRight];
		Err = SensorValue[myGyro]-900;
		IErr = IErr + Err;
		moveRobot(50 + 0.4*Err+ 0.0001*IErr,50 - 0.4*Err - 0.0001*IErr);
	}
	moveRobot(0,0);
	delay(50);


	//go straight little to get the second line
	nMotorEncoder[backRight]=robotEncoder=0;
	IErr=0;

	while(robotEncoder<180){
		robotEncoder=	nMotorEncoder[backRight];
		Err = SensorValue[myGyro]-900;
		IErr = IErr + Err;
		moveRobot(50 + 0.4*Err+ 0.0001*IErr,50 - 0.4*Err - 0.0001*IErr);
	}
	moveRobot(0,0);
	delay(50);

	//turn left 90 degree to adjust direction on second line
	while(SensorValue[myGyro]>100)
	{
		moveRobot(60,-60);
	}
	moveRobot(0,0);
	clearTimer(T2);
	while(time1(T2)<800)
	{
		Err = SensorValue[myGyro];
		moveRobot(0.4*Err,-0.4*Err);
	}
	moveRobot(0,0);
	delay(50);

	//go back to setup the gyro  and adjust direction on second line
	clearTimer(T3);
	while(((SensorValue[leftTouch]!=1) ||( SensorValue[rightTouch]!=1))&&(time1(T3)<2000)){
		moveRobot(-70 ,-70);
	}
	moveRobot(0,0);
	delay(50);


	//go straight and eat a ball from the second cap in the second line

	SensorValue[myGyro]=0;
	nMotorEncoder[backRight]=robotEncoder=0;
	IErr=0;

	while(robotEncoder<1500){
		if(robotEncoder>600)eatSecondBall();
		robotEncoder=	nMotorEncoder[backRight];
		Err = SensorValue[myGyro];
		IErr = IErr + Err;
		moveRobot(50 + 0.4*Err+ 0.0001*IErr,50 - 0.4*Err - 0.0001*IErr);
	}
	moveRobot(0,0);

	delay(50);

	////go back little to adjust position for shooting the high ,second flag
	//IErr=0;
	//nMotorEncoder[backRight]=robotEncoder=0;

	//while(robotEncoder>-500){
	//	robotEncoder=nMotorEncoder[backRight];
	//	Err = SensorValue[myGyro];
	//	IErr = IErr + Err;
	//	moveRobot(-50 + 0.4*Err+ 0.0001*IErr,-50 -0.4*Err - 0.0001*IErr);
	//}
	//moveRobot(0,0);
	//stopIntakes();


	////turn left 450 degree to adjust position for shooting the high ,second flag
	//while(SensorValue[myGyro] > -300)
	//{
	//	moveRobot(40,-40);
	//}
	//moveRobot(0,0);
	//clearTimer(T3);
	//while(time1(T3)<800)
	//{
	//	Err = SensorValue[myGyro] + 450;
	//	moveRobot(0.25*Err,-0.25*Err);
	//}
	//moveRobot(0,0);
	//delay(50);

	////	eject golf for shooting the high ,second flag if possible
	//clearTimer(T4);
	//while(time1(T4)<1000){

	//	ejectGolf();
	//}
	//stopGolf();

	////go straight and eat second  ball from you to second flag
	//eatBall();
	//nMotorEncoder[backRight]=robotEncoder=0;
	//IErr=0;

	//while(robotEncoder<600){
	//	robotEncoder=	nMotorEncoder[backRight];
	//	Err = SensorValue[myGyro]+450;
	//	IErr = IErr + Err;
	//	moveRobot(40 + 0.2*Err+ 0.0001*IErr,40 - 0.2*Err - 0.0001*IErr);
	//}
	//moveRobot(0,0);
	//stopIntakes();
	//delay(100);

	////	eject second golf to second flag in the middle of field
	//clearTimer(T1);
	//while(time1(T1)<1000){

	//	ejectGolf();
	//}
	//stopGolf();


	//	//turn left 35 degree to adjust position turning your back to the parking
	//while(SensorValue[myGyro] > -700)
	//{
	//	moveRobot(40,-40);
	//}
	//moveRobot(0,0);
	//clearTimer(T3);
	//while(time1(T3)<800)
	//{
	//	Err = SensorValue[myGyro] + 900;
	//	moveRobot(0.25*Err,-0.25*Err);
	//}
	//moveRobot(0,0);
	//delay(50);

	//	//go back to attend the parking
	//IErr=0;
	//nMotorEncoder[backRight]=robotEncoder=0;

	//while(robotEncoder>-525){
	//	Err = SensorValue[myGyro]+900;
	//	IErr = IErr + Err;
	//	robotEncoder=	nMotorEncoder[backRight];
	//	moveRobot(-40 +0.4*Err+0.0001*IErr,-40 -0.4*Err - 0.0001*IErr);
	//}
	//moveRobot(0,0);


	////turn right 90 degree to turn your back to the field wall
	//while(SensorValue[myGyro]<-150)
	//{
	//	moveRobot(-50,+50);
	//}
	//moveRobot(0,0);
	//clearTimer(T3);
	//while(time1(T3)<900)
	//{
	//	Err = SensorValue[myGyro];
	//	moveRobot(0.5*Err,-0.5*Err);
	//}
	//moveRobot(0,0);
	//delay(50);


	stopIntakes();


	//go back to setup the gyro go to parking
	IErr=0;
	clearTimer(T3);
	while(((SensorValue[leftTouch]!=1) ||( SensorValue[rightTouch]!=1))&&(time1(T3)<3000)){
		Err = SensorValue[myGyro];
		IErr = IErr + Err;
		moveRobot(-70 + 0.1*Err+ 0.0001*IErr,-70 -0.1*Err - 0.0001*IErr);
	}
	moveRobot(0,0);
	delay(50);
	SensorValue[myGyro]=0;



	//turn right 90 degree to attend parking
	while(SensorValue[myGyro] <800)
	{
		moveRobot(-50,50);
	}
	moveRobot(0,0);
	clearTimer(T4);
	while(time1(T4)<900)

	{
		Err = SensorValue[myGyro] -900;
		moveRobot(0.4*Err,-0.4*Err);
	}

	moveRobot(0,0);
	delay(50);

	//go straight on the blue tile to the parking
	nMotorEncoder[backRight]=robotEncoder=0;
	IErr=0;
	while((SensorValue[lFLeft]<1000) ||( SensorValue[lFRight]<1000)){
		robotEncoder=	nMotorEncoder[backRight];
		Err = SensorValue[myGyro]-900;
		IErr = IErr + Err;
		moveRobot(50 + 0.6*Err+ 0.0001*IErr,50 - 0.6*Err - 0.0001*IErr);
	}
	moveRobot(0,0);
	delay(50);


	//go straight on the black tile to the parking
	while(((SensorValue[lFLeft]>1000) &&( SensorValue[lFRight]>1000))){
		moveRobot(40,40);
	}
	moveRobot(0,0);
	delay(50);


	//go back little to adjust your position at the parking
	IErr=0;
	nMotorEncoder[backRight]=robotEncoder=0;

	while(robotEncoder>-450){
		robotEncoder=	nMotorEncoder[backRight];
		Err = SensorValue[myGyro]-900;
		IErr = IErr + Err;
		moveRobot(-40 + 0.1*Err+ 0.0001*IErr,-40 -0.1*Err - 0.0001*IErr);
	}
	moveRobot(0,0);
delay(50);

	//turn left 90 degree to look to the parking
	while(SensorValue[myGyro]>50)
	{
		moveRobot(50,-50);
	}
	//go back to setup the gyro at the parking
	clearTimer(T1);
	while(((SensorValue[leftTouch]!=1) ||( SensorValue[rightTouch]!=1))&&(time1(T1)<1500)){
		moveRobot(-70 ,-70);
	}
	moveRobot(0,0);
	delay(50);




	//go straight on the parking

	SensorValue[myGyro]=0;
	nMotorEncoder[backRight]=robotEncoder=0;
	IErr=0;
	while(robotEncoder<1500){
		robotEncoder=	nMotorEncoder[backRight];
		Err = SensorValue[myGyro];
		IErr = IErr + Err;
		moveRobot(120 + 0.6*Err+ 0.0001*IErr,120 - 0.6*Err - 0.0001*IErr);

	}

	moveRobot(0,0);


	////go straight little
	//nMotorEncoder[backRight]=robotEncoder=0;
	//IErr=0;

	//while(robotEncoder<400){
	//	robotEncoder=	nMotorEncoder[backRight];
	//	Err = SensorValue[myGyro]+550;
	//	IErr = IErr + Err;
	//	moveRobot(40 + 0.2*Err+ 0.0001*IErr,40 - 0.2*Err - 0.0001*IErr);
	//}
	//moveRobot(0,0);
	//stopIntakes();
	//delay(100);



	////go straight to turn the low flag in the middle of field
	//IErr=0;
	//clearTimer(T2);
	//while(time1(T2)<2200){
	//	moveRobot(50,40);
	//}
	//moveRobot(0,0);
	//delay(50);

	////turn left 40 degree to adjust position for shooting the low final flag ///////////////////////////
	//while(SensorValue[myGyro] > -700)
	//{
	//	moveRobot(40,-40);
	//}
	//moveRobot(0,0);
	//clearTimer(T3);
	//while(time1(T3)<800)
	//{
	//	Err = SensorValue[myGyro] + 900;
	//	moveRobot(0.25*Err,-0.25*Err);
	//}
	//moveRobot(0,0);
	//delay(50);

	////final flag
	//clearTimer(T2);
	//while(time1(T2)<1600){
	//	moveRobot(50,50);
	//}
	//moveRobot(0,0);
	//delay(50);

	////go back to attend the parking
	//IErr=0;
	//nMotorEncoder[backRight]=robotEncoder=0;

	//while(robotEncoder>-1400){
	//	Err = SensorValue[myGyro]+900;
	//	IErr = IErr + Err;
	//	robotEncoder=	nMotorEncoder[backRight];
	//	moveRobot(-50 -0.6*Err*0- 0.0001*IErr*0,-50 +0.6*Err*0 + 0.0001*IErr*0);
	//}
	//moveRobot(0,0);


	////turn left 90 degree to turn your head to the field wall
	//while(SensorValue[myGyro]>-1600)
	//{
	//	moveRobot(+50,-50);
	//}
	//moveRobot(0,0);
	//clearTimer(T3);
	//while(time1(T3)<900)
	//{
	//	Err = SensorValue[myGyro]+1800;
	//	moveRobot(0.5*Err,-0.5*Err);
	//}
	//moveRobot(0,0);
	//delay(50);



	////go straight  to the parking
	//nMotorEncoder[backRight]=robotEncoder=0;
	//IErr=0;
	//while(SensorValue[myGyro]>-2700)moveRobot(50,-20);






	////go straight on the parking

	//SensorValue[myGyro]=0;
	//nMotorEncoder[backRight]=robotEncoder=0;
	//IErr=0;
	//while(robotEncoder<600){
	//	robotEncoder=	nMotorEncoder[backRight];
	//	Err = SensorValue[myGyro];
	//	IErr = IErr + Err;
	//	moveRobot(110 + 0.6*Err+ 0.0001*IErr,110 - 0.6*Err - 0.0001*IErr);

	//}

	////stop robot
	//moveRobot(0,0);
	//moveRobot(-40,-40);
	//delay(100);
	//moveRobot(0,0);


}

task usercontrol()
{

	//delay(4000);
	//startTask(autonomous);

	//user control

	int a,b;








	startTask(MotorSlewRateTask);

	while (true)
	{

		a = vexRT[Ch3];
		b = vexRT[Ch2];
		if(abs(a) < 20){a = 0;}
		if(abs(b) < 20){b = 0;}
		if(a*b < 0){a = 3*a/5;b = 3*b/5;}
		moveRobot(a,b);


		if(vexRT[Btn6U]){
			eatBall();
		}


		if(vexRT[Btn6D]){
			invertCap();
		}

		if(vexRT[Btn8R]){
			stopIntakes();
		}
		if(vexRT[Btn8U]){
			eatSecondBall();
		}

		if(vexRT[Btn5U]){

			ejectGolf();
		}


		if(vexRT[Btn5D]){
			stopGolf();

		}











	}// EoWhile



}

	void moveRobot(int LSpeed, int RSpeed)
	{
		motorReq[frontLeft] = LSpeed;
		motorReq[backLeft] = LSpeed;
		motorReq[frontRight] = RSpeed;
		motorReq[backRight] = RSpeed;
	}
	void eatBall(){
		motorReq[lowIntake]=127;
		motorReq[highIntake]=127;
	}

	void invertCap(){
		motorReq[lowIntake]=-127;
		motorReq[highIntake]=0;
	}

	void stopIntakes(){
		motorReq[lowIntake]=0;
		motorReq[highIntake]=0;
	}
	void ejectGolf(){
		motorReq[golfDown]=motorReq[golfUP]=100;
	}
	void eatSecondBall(){
		motorReq[lowIntake]=127;
		motorReq[highIntake]=-127;
	}
	void stopGolf(){
		motorReq[golfDown]=0;
		motorReq[golfUP]=0;
	}
