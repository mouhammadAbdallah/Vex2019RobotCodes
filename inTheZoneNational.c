#pragma config(Sensor, in1,    myGyro,         sensorGyro)
#pragma config(Sensor, in2,    clawsPot,       sensorPotentiometer)
#pragma config(Sensor, in3,    backLim,        sensorLineFollower)
#pragma config(Sensor, in4,    frontLim,       sensorLineFollower)
#pragma config(Sensor, dgtl1,  craneEnc,       sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  RightBump,      sensorTouch)
#pragma config(Sensor, dgtl4,  LeftBump,       sensorTouch)
#pragma config(Sensor, dgtl5,  AdjtSwitch,     sensorTouch)
#pragma config(Sensor, dgtl6,  RorB,           sensorTouch)
#pragma config(Sensor, dgtl7,  AdjtSwitch2,    sensorTouch)
#pragma config(Motor,  port1,           MobGoalntake,  tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           frontRight1,   tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           frontLeftExp,  tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port4,           rightClaws,    tmotorVex393TurboSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           backRight,     tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           backLeft,      tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port7,           leftClaws,     tmotorVex393TurboSpeed_MC29, openLoop)
#pragma config(Motor,  port8,           craneMotorsExp, tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port9,           frontRight2,   tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port10,          rollerMotor,   tmotorVex393_HBridge, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX2)


#pragma competitionControl(Competition)


#include "Vex_Competition_Includes.c"
#define MOTOR_NUM               kNumbOfTotalMotors
#define MOTOR_MAX_VALUE         127
#define MOTOR_MIN_VALUE         (-127)
#define MOTOR_DEFAULT_SLEW_RATE 30      // Default will cause 375mS from full fwd to rev
#define MOTOR_FAST_SLEW_RATE    256     // essentially off
#define MOTOR_TASK_DELAY        20      // task 1/frequency in mS (about 66Hz)
#define MOTOR_DEADBAND          10
#define MAX_CMD									127


void moveClawsTo(int clawsTar);
void moveClawsWith(int speed);
void moveCraneWith(int speed);
void moveCraneTo(int craneTar);
void moveRobot(int RSpeed, int LSpeed);
void turnRollerToEject();
void turnRollerToEat();

int motorReq[MOTOR_NUM];
int motorSlew[MOTOR_NUM];

int PotVal = 0;
int craneEncVal = 0;
bool clawsUp = false;
bool clawsDown = false;
bool clawsMid = false;
bool craneUp = false;
bool craneDown = false;
bool MobInDown = false;
bool MobInUp = false;
int craneVals[11] = {0,40,80,110,130,160,190,210,240,270,300};
int craneValsH[11] = {0,100,150,175,200,225,250,275,300,325,350};
int craneValsHFeeder[11] = {90,110,150,175,200,225,250,275,300,325,350};
bool postfield = false;
bool prefield = false;
bool fieldMode = false;
bool goOnField = false;
bool prefeeder = false;
bool clawsRecv = false;
int ICraneErr = 0;
int fieldCount = 0;
int feederCount = 1;
int conesCount = 0;
bool feederMode = false;
bool goOnFeeder = false;
int nbSteps = 0;
int currentStep = 0;
int gyroVal = 0;
int Err = 0;
int Blue = false;
int IErr = 0;
task MotorSlewRateTask()
{
	int motorIndex;
	int motorTmp;


	// Initialize stuff
	for (motorIndex = 0; motorIndex < (signed)MOTOR_NUM; motorIndex++)
	{
		motorReq[motorIndex] = 0;
		motorSlew[motorIndex] = MOTOR_DEFAULT_SLEW_RATE;
	}

	// run task until stopped
	while (true)
	{
		// run loop for every motor
		for (motorIndex = 0; motorIndex < (signed)MOTOR_NUM; motorIndex++)
		{
			// So we don't keep accessing the internal storage
			motorTmp = motor[motorIndex];

			// Do we need to change the motor value ?
			if (motorTmp != motorReq[motorIndex])
			{
				// increasing motor value
				if (motorReq[motorIndex] > motorTmp)
				{
					motorTmp += motorSlew[motorIndex];
					// limit
					if (motorTmp > motorReq[motorIndex])
						motorTmp = motorReq[motorIndex];
				}

				// decreasing motor value
				if (motorReq[motorIndex] < motorTmp)
				{
					motorTmp -= motorSlew[motorIndex];
					// limit
					if (motorTmp < motorReq[motorIndex])
						motorTmp = motorReq[motorIndex];
				}

				// finally set motor
				motor[motorIndex] = motorTmp;
			}
		}

		// Wait approx the speed of motor update over the spi bus
		wait1Msec(MOTOR_TASK_DELAY);
	}
}

void pre_auton()
{
	bStopTasksBetweenModes = true;
	SensorValue[craneEnc] = 0;
	SensorValue[myGyro] = 0;
	nMotorEncoder[frontRight2] = 0;
}
task autonomous()
{
	if(SensorValue[RorB] == 0)
	{
		Blue = true;
	}
	else
	{
		Blue = false;
	}
	nMotorEncoder[frontRight2] = 0;
	startTask(MotorSlewRateTask);
	SensorValue[myGyro]= 0;
	Err = 0;
	//move Robot to Goal 1
	clearTimer(T1);
	while(nMotorEncoder[frontRight2] < 1100 || SensorValue[backLim] > 1700)
	{
		Err = SensorValue[myGyro];
		moveRobot(60 - 0.3*Err,60 + 0.3*Err);
		if(time1(T1) < 800)
		{
			motorReq[MobGoalntake] = -127;
		}
		else
		{
			motorReq[MobGoalntake] = 0;
		}
		if(time1(T1) > 5000)
			{
				while(true)
					{
						moveRobot(0,0);
					}
			}
	}
	moveRobot(0,0);
	nMotorEncoder[frontRight2] = 0;
	while(nMotorEncoder[frontRight2] < 250)
	{
		Err = SensorValue[myGyro];
		moveRobot(60 - 0.3*Err,60 + 0.3*Err);
	}
	moveRobot(0,0);
	//put goal on robot
	clearTimer(T1);
	while(time1(T1)<1000)
	{
		motorReq[MobGoalntake] = 127;
		Err = SensorValue[myGyro];
		moveRobot(-0.3*Err,0.3*Err);
	}
	moveRobot(0,0);
	motorReq[MobGoalntake] = 0;
	clearTimer(T1);
	while(time1(T1)<500)
	{
		turnRollerToEject();
	}
	//cone scored
	motorReq[rollerMotor] = 0;
	nMotorEncoder[frontRight2] = 0;
	//go to the second cone
	while(nMotorEncoder[frontRight2] < 60)
	{
		Err = SensorValue[myGyro];
		moveRobot(60 - 0.3*Err,60 + 0.3*Err);
	}
	moveRobot(0,0);
	clearTimer(T1);
	while(time1(T1) < 1500)
	{
		moveClawsTo(1000);
		turnRollerToEat();
	}
	motorReq[rollerMotor] = 0;
	moveClawsWith(0);
	clearTimer(T1);
	while(time1(T1) < 1000)
	{
		motorReq[rollerMotor] = 30;
		if(SensorValue[clawsPot] < 2600){moveClawsTo(3300);motorReq[rollerMotor] = 30;}
		else{moveClawsWith(0);}
	}
	clearTimer(T1);
	while(time1(T1) < 500)
	{
		turnRollerToEject();
	}
	//second cone on the Robot
	//moving back
	motorReq[rollerMotor] = 0;
	nMotorEncoder[frontRight2] = 0;
	while(abs(nMotorEncoder[frontRight2]) < 2100 || SensorValue[frontLim] > 1500)
	{
		Err = SensorValue[myGyro];
		moveRobot(-60 - 0.5*Err,-60 + 0.5*Err);
	}
	moveRobot(0,0);
	clearTimer(T1);
	while(time1(T1) < 100)
	{
		moveRobot(60,60);
	}
	//turn 1
	moveRobot(0,0);
	if(Blue)
	{
		while(SensorValue[myGyro] < 300)
		{
			moveRobot(60,-60);
		}
		moveRobot(0,0);
		clearTimer(T1);
		while(time1(T1) < 800)
		{
			Err = SensorValue[myGyro] - 450;
			moveRobot(-0.3*Err,0.3*Err);
		}
		moveRobot(0,0);
		nMotorEncoder[frontRight2] = 0;
		clearTimer(T1);
		while(nMotorEncoder[frontRight2] > -1100 || time1(T1) < 1000)
		{
			Err = SensorValue[myGyro] - 450;
			moveRobot(-60 - 0.3*Err,-60 + 0.3*Err);
		}
		moveRobot(0,0);
		//turn 2 : going to score
		while(SensorValue[myGyro] < 1200)
		{
			moveRobot(60,-60);
		}
		moveRobot(0,0);
		clearTimer(T1);
		while(time1(T1)<1000)
		{
			Err = SensorValue[myGyro] - 1350;
			moveRobot(-0.4*Err,0.4*Err);
		}
	}
	else
	{
		while(SensorValue[myGyro] > -300)
		{
			moveRobot(-60,60);
		}
		moveRobot(0,0);
		clearTimer(T1);
		while(time1(T1) < 800)
		{
			Err = SensorValue[myGyro] + 450;
			moveRobot(0.3*Err,-0.3*Err);
		}
		moveRobot(0,0);
		nMotorEncoder[frontRight2] = 0;
		clearTimer(T1);
		while(nMotorEncoder[frontRight2] > -1100 || time1(T1) < 1000)
		{
			Err = SensorValue[myGyro] + 450;
			moveRobot(-60 + 0.3*Err,-60 - 0.3*Err);
		}
		moveRobot(0,0);
		//turn 2 : going to score
		while(SensorValue[myGyro] > -1200)
		{
			moveRobot(-60,60);
		}
		moveRobot(0,0);
		clearTimer(T1);
		while(time1(T1)<1000)
		{
			Err = SensorValue[myGyro] + 1350;
			moveRobot(-0.4*Err,0.4*Err);
		}
	}
	//from skills
	clearTimer(T1);
	while(time1(T1) < 500)
	{

	}
	clearTimer(T1);
	while(time1(T1) < 1200)
	{
		moveRobot(127,127);
		if(time1(T1) > 500)
		{
			motorReq[MobGoalntake] = -127;
		}
	}
	motorReq[MobGoalntake]  = 0;
	moveRobot(0,0);
	clearTimer(T1);
	while(time1(T1) < 300)
	{
		moveRobot(-127,-127);
	}
	moveRobot(0,0);
	clearTimer(T1);
	while(time1(T1) < 400)
	{
		moveRobot(127,127);
	}
	moveRobot(0,0);
	clearTimer(T1);
	while(time1(T1) < 300)
	{
		moveRobot(-127,-127);
	}
	moveRobot(0,0);
	clearTimer(T1);
	while(time1(T1) < 400)
	{
		moveRobot(127,127);
	}
	moveRobot(0,0);
	nMotorEncoder[frontRight2] = 0;
	clearTimer(T1);
	while(time1(T1) < 600)
	{
		motorReq[MobGoalntake] = 127;
	}
	motorReq[MobGoalntake] = 0;

	while(abs(nMotorEncoder[frontRight2]) < 600)
	{
		if(abs(nMotorEncoder[frontRight2])> 100)
		{
			motorReq[MobGoalntake] = -127;
		}
		else
		{
			motorReq[MobGoalntake] = 0;
		}
		moveRobot(-50,-50);
	}
	moveRobot(0,0);
	clearTimer(T1);
	while(time1(T1) < 600)
	{
		motorReq[MobGoalntake] = 127;
	}
	motorReq[MobGoalntake] = 0;
	SensorValue[myGyro] = 0;
	//end
	if(Blue){
		while(SensorValue[myGyro] > -600)
		{
			moveRobot(-50,50);
		}
		moveRobot(0,0);
		while(SensorValue[AdjtSwitch] == 0)
		{
			moveCraneTo(150);
			Err = SensorValue[myGyro] + 900;
			moveRobot(-40 - 0.3*Err, -40 + 0.3*Err);
		}
		moveRobot(0,0);
		while(SensorValue[myGyro] > -1350)
		{
			moveRobot(-50,0);
			moveCraneTo(150);
		}
		moveRobot(0,0);
		clearTimer(T2);
		while(true)
		{
			moveCraneTo(150);
			moveRobot(-60,-60);
			if(time1(T2) > 250)
			{
				break;
			}
		}
	}
	else
	{
		while(SensorValue[myGyro] < 600)
		{
			moveRobot(50,-50);
		}
		moveRobot(0,0);
		while(SensorValue[AdjtSwitch2] == 0)
		{
			moveCraneTo(150);
			Err = SensorValue[myGyro] - 900;
			moveRobot(-40 - 0.3*Err, -40 + 0.3*Err);
		}
		moveRobot(0,0);
		while(SensorValue[myGyro] < 1350)
		{
			moveRobot(0,-50);
			moveCraneTo(150);
		}
		moveRobot(0,0);
		clearTimer(T2);
		while(true)
		{
			moveCraneTo(150);
			moveRobot(-60,-60);
			if(time1(T2) > 250)
			{
				break;
			}
		}
	}

	////go to second cone
	moveRobot(0,0);
	SensorValue[myGyro] = 0;
	nMotorEncoder[frontRight2] = 0;
	while(nMotorEncoder[frontRight2] < 550)
	{
		moveRobot(50,50);
		moveCraneTo(150);
	}
	moveRobot(0,0);
	moveCraneWith(0);
	clearTimer(T1);
	while(time1(T1) < 800)
	{
		moveCraneTo(0);
	}
	moveCraneWith(0);
	if(Blue){
		while(SensorValue[myGyro] > -700)
		{
			moveRobot(-50,50);
		}
		moveRobot(0,0);
		Err = 0;
		clearTimer(T1);
		while(time1(T1) < 1000)
		{
			Err = SensorValue[myGyro] + 900;
			moveRobot(-0.3*Err,0.3*Err);
		}
		moveRobot(0,0);
		Err = 0;
		nMotorEncoder[frontRight2] = 0;
		while(nMotorEncoder[frontRight2] < 550 && SensorValue[frontLim] > 1500)
		{
			Err = SensorValue[myGyro] + 900;
			moveRobot(50 - 0.3*Err,50 + 0.3*Err);
		}
	}
	else
	{
		while(SensorValue[myGyro] < 700)
		{
			moveRobot(50,-50);
		}
		moveRobot(0,0);
		Err = 0;
		clearTimer(T1);
		while(time1(T1) < 1000)
		{
			Err = SensorValue[myGyro] - 900;
			moveRobot(-0.3*Err,0.3*Err);
		}
		moveRobot(0,0);
		Err = 0;
		nMotorEncoder[frontRight2] = 0;
		while(nMotorEncoder[frontRight2] < 550 && SensorValue[frontLim] > 1500)
		{
			Err = SensorValue[myGyro] - 900;
			moveRobot(50 - 0.3*Err,50 + 0.3*Err);
		}
	}
	clearTimer(T1);
	while(time1(T1)<100)
	{
		moveRobot(-50,-50);
	}
	moveRobot(0,0);
	clearTimer(T1);
	while(time1(T1) < 1500)
	{
		turnRollerToEat();
		moveClawsTo(1000);
	}
	moveClawsWith(0);
	motorReq[rollerMotor] = 0;
	clearTimer(T1);
	while(time1(T1)<1000)
	{
		motorReq[rollerMotor] = 50;
		if(SensorValue[clawsPot] < 2300){moveClawsTo(3300);motorReq[rollerMotor] = 30;}
		else{moveClawsWith(0);}
	}
	Err = 0;
	if(Blue){
		clearTimer(T1);
		while(time1(T1) < 1000)
		{
			if(time1(T1) < 800)
			{
				motorReq[MobGoalntake] = -127;
			}
			else
			{
				motorReq[MobGoalntake] = 0;
			}
			Err = SensorValue[myGyro] + 1050;
			moveRobot(-0.2*Err,+0.2*Err);
		}
		moveRobot(0,0);
		nMotorEncoder[frontRight2] = 0;
		while(nMotorEncoder[frontRight2] < 1500)
		{
			Err = SensorValue[myGyro] + 1050;
			moveRobot(50 - 0.3*Err,50 + 0.3*Err);
		}
	}
	else
	{
		clearTimer(T1);
		while(time1(T1) < 1000)
		{
			if(time1(T1) < 800)
			{
				motorReq[MobGoalntake] = -127;
			}
			else
			{
				motorReq[MobGoalntake] = 0;
			}
			Err = SensorValue[myGyro] - 1050;
			moveRobot(-0.2*Err,+0.2*Err);
		}
		moveRobot(0,0);
		nMotorEncoder[frontRight2] = 0;
		while(nMotorEncoder[frontRight2] < 1500)
		{
			Err = SensorValue[myGyro] - 1050;
			moveRobot(60 - 0.3*Err,60 + 0.3*Err);
		}
	}
	moveRobot(0,0);
	clearTimer(T1);
	while(time1(T1) < 1000)
	{
		motorReq[MobGoalntake] = 127;
	}
	motorReq[MobGoalntake] = 0;
	clearTimer(T1);
	while(time1(T1) < 500)
	{
		turnRollerToEject();
	}
	motorReq[rollerMotor] = 0;
	if(Blue)
	{
		nMotorEncoder[frontRight2] = 0;
		clearTimer(T1);
		while(nMotorEncoder[frontRight2] > -1700)
		{
			if(time1(T1) < 500)
			{
				turnRollerToEject();
			}
			else
			{
				motorReq[rollerMotor] = 0;
			}
			Err = SensorValue[myGyro] + 1050;
			moveRobot(-50 - 0.3*Err,-50 + 0.3*Err);
		}
		moveRobot(0,0);
		Err = 0;
		nMotorEncoder[frontRight2] = 0;
		while(SensorValue[frontLim] > 1500 || abs(nMotorEncoder[frontRight2]) < 500)
		{
			Err = SensorValue[myGyro] + 900;
			moveRobot(-50 - 0.3*Err,-50 + 0.3*Err);
		}
		moveRobot(0,0);
		clearTimer(T1);
		while(time1(T1) < 1000)
		{
			Err = SensorValue[myGyro] + 2250;
			moveRobot(-0.3*Err,0.3*Err);
		}
		moveRobot(0,0);
		clearTimer(T1);
		while(time1(T1)< 600)
		{
			motorReq[MobGoalntake] = -127;
			moveRobot(50,50);
		}
		motorReq[MobGoalntake] = 0;
		moveRobot(-50,-50);
	}
	else
	{
		nMotorEncoder[frontRight2] = 0;
		clearTimer(T1);
		while(nMotorEncoder[frontRight2] > -1700)
		{
			if(time1(T1) < 500)
			{
				turnRollerToEject();
			}
			else
			{
				motorReq[rollerMotor] = 0;
			}
			Err = SensorValue[myGyro] - 1050;
			moveRobot(-50 - 0.3*Err,-50 + 0.3*Err);
		}
		moveRobot(0,0);
		Err = 0;
		nMotorEncoder[frontRight2] = 0;
		while(SensorValue[frontLim] > 1500 || abs(nMotorEncoder[frontRight2]) < 500)
		{
			Err = SensorValue[myGyro] - 900;
			moveRobot(-50 - 0.3*Err,-50 + 0.3*Err);
		}
		moveRobot(0,0);
		clearTimer(T1);
		while(time1(T1) < 1000)
		{
			Err = SensorValue[myGyro] - 2250;
			moveRobot(-0.3*Err,0.3*Err);
		}
		moveRobot(0,0);
		clearTimer(T1);
		while(time1(T1)< 600)
		{
			motorReq[MobGoalntake] = -127;
			moveRobot(50,50);
		}
		motorReq[MobGoalntake] = 0;
		moveRobot(-50,-50);
	}
	clearTimer(T1);
	while(time1(T1)<500){}
	moveRobot(0,0);
}

task usercontrol()
{
	startTask(MotorSlewRateTask);
	SensorValue[craneEnc] = 0;
	SensorValue[myGyro] = 0;
	int c = 0;
	while (true)
	{
		PotVal = SensorValue[backLim];
		craneEncVal = SensorValue[craneEnc];
		nbSteps = nMotorEncoder[frontRight2];
		gyroVal = SensorValue[myGyro];
		while(vexRT[Btn6UXmtr2])
		{
			turnRollerToEat();
		}

		while(vexRT[Btn6DXmtr2])
		{
			turnRollerToEject();
		}

		motorReq[rollerMotor] = 0;
		if(vexRT[Btn8L] && vexRT[Btn8R])
		{
			fieldCount = 0;
			feederCount = 1;
			conesCount = 0;
		}
		if(vexRT[Btn6U] && !vexRT[Btn6D])
		{
			MobInUp = true;
			MobInDown = false;

		}
		if(vexRT[Btn6D] && !vexRT[Btn6U])
		{
			MobInUp = false;
			MobInDown = true;
		}
		if(!vexRT[Btn6D] && !vexRT[Btn6U])
		{
			MobInUp = false;
			MobInDown = false;
		}
		if(MobInUp && !MobInDown)
		{
			motorReq[MobGoalntake] = 127;
		}
		else if(!MobInUp && MobInDown)
		{
			motorReq[MobGoalntake] = -127;
		}
		else
		{
			motorReq[MobGoalntake] = 0;
		}

		if(vexRT[Btn7UXmtr2] && !feederMode)
		{
			prefeeder = true;
			postfield = false;
			prefield = false;
		}
			if(vexRT[Btn8LXmtr2] && !fieldMode)
		{
			clawsRecv = true;
		}
		if(vexRT[Btn8UXmtr2] && !fieldMode)
		{
			prefeeder = false;
			prefield = false;
			postfield = true;
		}
		if(vexRT[Btn8DXmtr2] && !fieldMode)
		{
			prefeeder = false;
			prefield = true;
			postfield = false;
		}
		if(vexRT[Btn7U])
		{
			feederMode = true;
			goOnFeeder = true;
			fieldMode = false;
			goOnField = false;
			prefeeder = false;
			postfield = false;
			prefield = false;

		}
		if(vexRT[Btn7D])
		{
			feederMode = false;
			goOnFeeder = false;

		}
		if(vexRT[Btn8U])
		{
			fieldMode = true;
			goOnField = true;
			clawsRecv = false;
			feederMode = false;
			goOnFeeder = false;
			prefield = false;
			prefeeder = false;
			postfield = false;

		}
		if(vexRT[Btn8D])
		{
			fieldMode = false;
			goOnField = false;
		}
		if(clawsRecv && !fieldMode)
		{
				if(SensorValue[clawsPot] < 3000)
				{
					moveClawsTo(3300);
				}
				else
					{
						moveClawsWith(0);
						clawsRecv = false;
					}
		}
		if(prefeeder)
		{
			moveCraneTo(130);
			moveClawsTo(2000);
		}
		if(prefield)
		{
			if(SensorValue[craneEnc] > 20){
				moveCraneTo(0);
			}
			else
			{
				moveCraneWith(0);
			}
			if(SensorValue[clawsPot] < 2300){moveClawsTo(3300);}
			else{moveClawsWith(0);}
		}
		if(postfield)
		{
			motorReq[rollerMotor] = 0;
			moveCraneTo(300);
			moveClawsTo(1800);
			if(SensorValue[craneEnc] > 270){
				if(SensorValue[clawsPot] < 2300){moveClawsTo(3300);}
				else{moveClawsWith(0);}
			}
		}
		if(fieldMode)
		{
			int a1 = 0;
			int b1 = 0;
			bool man_aut;
			//moving claws to mid position
			if(conesCount == -1)
			{
				IErr = 0;
				while(!vexRT[Btn5DXmtr2] && goOnField)
				{
					if(vexRT[Btn8D])
					{
						goOnField = false;
						fieldMode = false;
					}
					moveClawsTo(1800);
					if(man_aut)
					{
						if(SensorValue[craneEnc] > 10)
						{moveCraneTo(0);}
						else
						{
							moveCraneWith(0);
						}
					}
					else
					{
						moveCraneWith(-127);
					}
					if(vexRT[Ch2Xmtr2] < -20)
					{
						man_aut = false;
					}
					else
					{
						man_aut = true;
					}

					a1 = vexRT[Ch2];
					b1 = vexRT[Ch3];
					if(abs(a1) < 15){a1 = 0;}
					if(abs(b1) < 15){b1 = 0;}
					if(a1*b1 < 0){a1 = 3*a1/5;b1 = 3*b1/5;}
					moveRobot(a1,b1);
					//CraneEncVal = SensorValue[CraneEnc];
					delay(10);
				}
				moveRobot(0,0);
				IErr = 0;
				while(!vexRT[Btn5UXmtr2] && goOnField)
				{
					if(vexRT[Btn8D])
					{
						goOnField = false;
						fieldMode = false;
					}
					moveClawsTo(1000);
					turnRollerToEat();
					a1 = vexRT[Ch2];
					b1 = vexRT[Ch3];
					if(abs(a1) < 15){a1 = 0;}
					if(abs(b1) < 15){b1 = 0;}
					if(a1*b1 < 0){a1 = 3*a1/5;b1 = 3*b1/5;}
					moveRobot(a1,b1);
					delay(10);
				}
				IErr = 0;
				while(!vexRT[Btn5DXmtr2] && goOnField)
				{
					if(vexRT[Btn8D])
					{
						goOnField = false;
						fieldMode = false;
					}
					moveClawsTo(2300);
					motorReq[rollerMotor] = 30;
					a1 = vexRT[Ch2];
					b1 = vexRT[Ch3];
					if(abs(a1) < 15){a1 = 0;}
					if(abs(b1) < 15){b1 = 0;}
					if(a1*b1 < 0){a1 = 3*a1/5;b1 = 3*b1/5;}
					moveRobot(a1,b1);
					delay(10);
				}
				IErr = 0;
				while(!vexRT[Btn5UXmtr2] && goOnField)
				{
					if(vexRT[Btn8D])
					{
						goOnField = false;
						fieldMode = false;
					}
					moveClawsTo(2300);
					turnRollerToEject();
					a1 = vexRT[Ch2];
					b1 = vexRT[Ch3];
					if(abs(a1) < 15){a1 = 0;}
					if(abs(b1) < 15){b1 = 0;}
					if(a1*b1 < 0){a1 = 3*a1/5;b1 = 3*b1/5;}
					moveRobot(a1,b1);
					delay(10);
				}
				IErr = 0;
				while(!vexRT[Btn5DXmtr2] && goOnField)
				{
					if(vexRT[Btn8D])
					{
						goOnField = false;
						fieldMode = false;
					}
					if(vexRT[Btn6U] && !vexRT[Btn6D])
					{
						motorReq[MobGoalntake] = 127;
					}
					if(!vexRT[Btn6U] && vexRT[Btn6D])
					{
						motorReq[MobGoalntake] = -127;
					}
					if(!vexRT[Btn6U] && !vexRT[Btn6D])
					{
						motorReq[MobGoalntake] = 0;
					}

					if(SensorValue[clawsPot] < 2600){moveClawsTo(3300);motorReq[rollerMotor] = 30;}
					else{moveClawsWith(0);}
					a1 = vexRT[Ch2];
					b1 = vexRT[Ch3];
					if(abs(a1) < 15){a1 = 0;}
					if(abs(b1) < 15){b1 = 0;}
					if(a1*b1 < 0){a1 = 3*a1/5;b1 = 3*b1/5;}
					moveRobot(a1,b1);
					delay(10);
				}
			}
			if(conesCount > 0){
				IErr = 0;
				while(!vexRT[Btn5DXmtr2] && goOnField)
				{
					if(vexRT[Btn8D])
					{
						goOnField = false;
						fieldMode = false;
					}
					moveClawsTo(1800);
					if(man_aut)
					{
						if(SensorValue[craneEnc] > 10)
						{moveCraneTo(0);}
						else
						{
							moveCraneWith(0);
						}
					}
					else
					{
						moveCraneWith(-127);
					}
					if(vexRT[Ch2Xmtr2] < -10)
					{
						man_aut = false;
					}
					else
					{
						man_aut = true;
					}
					a1 = vexRT[Ch2];
					b1 = vexRT[Ch3];
					if(abs(a1) < 15){a1 = 0;}
					if(abs(b1) < 15){b1 = 0;}
					if(a1*b1 < 0){a1 = 3*a1/5;b1 = 3*b1/5;}
					moveRobot(a1,b1);
					//CraneEncVal = SensorValue[CraneEnc];
					delay(10);
				}
				moveRobot(0,0);
				//claws down + Roller eating
				IErr = 0;
				while(!vexRT[Btn5UXmtr2] && goOnField)
				{
					if(vexRT[Btn8D])
					{
						goOnField = false;
						fieldMode = false;
					}
					moveClawsTo(1000);
					if(vexRT[Ch2Xmtr2] < -10)
					{
						man_aut = false;
					}
					else
					{
						man_aut = true;
					}
					if(man_aut)
					{
						if(SensorValue[craneEnc] > 10)
						{moveCraneTo(0);}
						else
						{
							moveCraneWith(0);
						}
					}
					else
					{
						moveCraneWith(-127);
					}
					turnRollerToEat();
					a1 = vexRT[Ch2];
					b1 = vexRT[Ch3];
					if(abs(a1) < 15){a1 = 0;}
					if(abs(b1) < 15){b1 = 0;}
					if(a1*b1 < 0){a1 = 3*a1/5;b1 = 3*b1/5;}
					moveRobot(a1,b1);
					delay(10);
				}
				//go back to mid position
				IErr = 0;
				while(!vexRT[Btn5DXmtr2] && goOnField)
				{
					if(vexRT[Btn8D])
					{
						goOnField = false;
						fieldMode = false;
					}
					motorReq[rollerMotor] = 30;
					moveClawsTo(1700);
					a1 = vexRT[Ch2];
					b1 = vexRT[Ch3];
					if(abs(a1) < 15){a1 = 0;}
					if(abs(b1) < 15){b1 = 0;}
					if(a1*b1 < 0){a1 = 3*a1/5;b1 = 3*b1/5;}
					moveRobot(a1,b1);

					delay(10);
				}
				//moving crane to desired position
				IErr = 0;
				while(!vexRT[Btn5UXmtr2] && goOnField)
				{
					if(vexRT[Btn8D])
					{
						goOnField = false;
						fieldMode = false;
					}
					moveClawsTo(1800);
					moveCraneTo(craneValsH[conesCount]);
					a1 = vexRT[Ch2];
					b1 = vexRT[Ch3];
					if(abs(a1) < 15){a1 = 0;}
					if(abs(b1) < 15){b1 = 0;}
					if(a1*b1 < 0){a1 = 3*a1/5;b1 = 3*b1/5;}
					moveRobot(a1,b1);

					delay(10);
				}
				//go back to eject claws position
				c = 0;
				while(!vexRT[Btn5DXmtr2] && goOnField)
				{
					if(vexRT[Btn8D])
					{
						goOnField = false;
						fieldMode = false;
					}
					moveCraneTo(craneValsH[conesCount]);
					if(SensorValue[clawsPot] < 2300){moveClawsTo(3300);motorReq[rollerMotor] = 30;}
					else{moveClawsWith(0);}
					a1 = vexRT[Ch2];
					b1 = vexRT[Ch3];
					if(abs(a1) < 15){a1 = 0;}
					if(abs(b1) < 15){b1 = 0;}
					if(a1*b1 < 0){a1 = 3*a1/5;b1 = 3*b1/5;}
					moveRobot(a1,b1);

					delay(10);
				}

				//go down to the desired crane Pos
				IErr = 0;
				while(!vexRT[Btn5UXmtr2] && goOnField)
				{
					if(vexRT[Btn8D])
					{
						goOnField = false;
						fieldMode = false;
					}
					if(SensorValue[craneEnc] > craneVals[conesCount])
					{
						moveCraneTo(craneVals[conesCount]);
					}
					else
					{
						moveCraneWith(0);
					}
					a1 = vexRT[Ch2];
					b1 = vexRT[Ch3];
					if(abs(a1) < 15){a1 = 0;}
					if(abs(b1) < 15){b1 = 0;}
					if(a1*b1 < 0){a1 = 3*a1/5;b1 = 3*b1/5;}
					moveRobot(a1,b1);

					delay(10);
				}
				//eject cone
				IErr = 0;
				clearTimer(T1);
				while(!vexRT[Btn5DXmtr2] && goOnField)
				{
					if(vexRT[Btn8D])
					{
						goOnField = false;
						fieldMode = false;
					}
					if(time1(T1) < 500){
						turnRollerToEject();
					}
					else
					{
						motorReq[rollerMotor] = 0;
						moveCraneTo(craneValsH[conesCount]);
					}
					a1 = vexRT[Ch2];
					b1 = vexRT[Ch3];
					if(abs(a1) < 15){a1 = 0;}
					if(abs(b1) < 15){b1 = 0;}
					if(a1*b1 < 0){a1 = 3*a1/5;b1 = 3*b1/5;}
					moveRobot(a1,b1);

					delay(10);
				}
				motorReq[rollerMotor] = 0;
				//go back to mid pos and move crane Down
				IErr = 0;
				while(!vexRT[Btn5UXmtr2] && goOnField)
				{
					if(vexRT[Btn8D])
					{
						goOnField = false;
						fieldMode = false;
					}
					moveClawsTo(1800);
					moveCraneTo(0);
					a1 = vexRT[Ch2];
					b1 = vexRT[Ch3];
					if(abs(a1) < 15){a1 = 0;}
					if(abs(b1) < 15){b1 = 0;}
					if(a1*b1 < 0){a1 = 3*a1/5;b1 = 3*b1/5;}
					moveRobot(a1,b1);

					delay(10);
				}
			}
			if(conesCount == 0)
			{
				IErr = 0;
				while(!vexRT[Btn5DXmtr2] && goOnField)
				{
					if(vexRT[Btn8D])
					{
						goOnField = false;
						fieldMode = false;
					}
					moveClawsTo(1800);
					if(man_aut)
					{
						if(SensorValue[craneEnc] > 10)
						{moveCraneTo(0);}
						else
						{
							moveCraneWith(0);
						}
					}
					else
					{
						moveCraneWith(-127);
					}
					if(vexRT[Ch2Xmtr2] < -10)
					{
						man_aut = false;
					}
					else
					{
						man_aut = true;
					}
					a1 = vexRT[Ch2];
					b1 = vexRT[Ch3];
					if(abs(a1) < 15){a1 = 0;}
					if(abs(b1) < 15){b1 = 0;}
					if(a1*b1 < 0){a1 = 3*a1/5;b1 = 3*b1/5;}
					moveRobot(a1,b1);
					//CraneEncVal = SensorValue[CraneEnc];
					delay(10);
				}
				moveRobot(0,0);
				//claws down + Roller eating
				IErr = 0;
				while(!vexRT[Btn5UXmtr2] && goOnField)
				{
					if(vexRT[Btn8D])
					{
						goOnField = false;
						fieldMode = false;
					}
					moveClawsTo(1000);
					turnRollerToEat();
					if(vexRT[Ch2Xmtr2] < -20){
						moveCraneWith(vexRT[Ch2Xmtr2]);
					}
					else
					{
						moveCraneWith(0);
					}
					a1 = vexRT[Ch2];
					b1 = vexRT[Ch3];
					if(abs(a1) < 15){a1 = 0;}
					if(abs(b1) < 15){b1 = 0;}
					if(a1*b1 < 0){a1 = 3*a1/5;b1 = 3*b1/5;}
					moveRobot(a1,b1);

					delay(10);
				}
				IErr = 0;
				while(!vexRT[Btn5DXmtr2] && goOnField)
				{
					if(vexRT[Btn8D])
					{
						goOnField = false;
						fieldMode = false;
					}
					if(SensorValue[clawsPot] < 2300){moveClawsTo(3300);motorReq[rollerMotor] = 30;}
					else{moveClawsWith(0);}
					if(vexRT[Ch2Xmtr2] < -10){
						moveCraneWith(-127);
					}
					else
					{
						moveCraneWith(0);
					}
					a1 = vexRT[Ch2];
					b1 = vexRT[Ch3];
					if(abs(a1) < 15){a1 = 0;}
					if(abs(b1) < 15){b1 = 0;}
					if(a1*b1 < 0){a1 = 3*a1/5;b1 = 3*b1/5;}
					moveRobot(a1,b1);

					delay(10);
				}
				IErr = 0;
				clearTimer(T1);
				while(!vexRT[Btn5UXmtr2] && goOnField)
				{
					if(vexRT[Btn8D])
					{
						goOnField = false;
						fieldMode = false;
					}
					if(time1(T1) < 500){
						turnRollerToEject();
					}
					else
					{
						motorReq[rollerMotor] = 0;
					}
					if(vexRT[Ch2Xmtr2] < -10){
						moveCraneWith(-127);
					}
					else
					{
						moveCraneWith(0);
					}
					a1 = vexRT[Ch2];
					b1 = vexRT[Ch3];
					if(abs(a1) < 15){a1 = 0;}
					if(abs(b1) < 15){b1 = 0;}
					if(a1*b1 < 0){a1 = 3*a1/5;b1 = 3*b1/5;}
					moveRobot(a1,b1);
					delay(10);

				}
				motorReq[rollerMotor] = 0;
			}
			moveCraneWith(0);
			IErr = 0;
			while(true && goOnField)
			{
				if(vexRT[Btn6U])
				{
					motorReq[MobGoalntake] = 127;
				}
				else if(vexRT[Btn6D])
				{
					motorReq[MobGoalntake] = -127;
				}
				else
				{
					motorReq[MobGoalntake] = 0;
				}
				a1 = vexRT[Ch2];
				b1 = vexRT[Ch3];
				if(abs(a1) < 15){a1 = 0;}
				if(abs(b1) < 15){b1 = 0;}
				if(a1*b1 < 0){a1 = 3*a1/5;b1 = 3*b1/5;}
				moveRobot(a1,b1);
				if(vexRT[Btn8D])
				{
					goOnField = false;
					fieldMode = false;
					break;
				}
				if(conesCount > 0){
					moveClawsTo(1800);
				}
				//fieldMode = false;
				if(vexRT[Btn5U])
				{
					if(conesCount < 12)
					{
						conesCount = conesCount + 1;
					}
					break;
				}
				if(vexRT[Btn5D])
				{
					break;
				}
			}
		}
		else
		{
			if(feederMode)
			{
				int a1 = 0;
				int b1 = 0;
				//go to crane 0 + eat
				while(!vexRT[Btn5DXmtr2] && goOnFeeder)
				{
					if(vexRT[Btn7D])
					{
						goOnFeeder = false;
						feederMode = false;
					}
					if(vexRT[Btn7L] || vexRT[Btn7R])
					{
						goOnFeeder = false;
						feederMode = false;
						prefeeder = true;
					}
					moveClawsTo(2000);
					moveCraneTo(0);
					turnRollerToEat();
					//a1 = vexRT[Ch2];
					//b1 = vexRT[Ch3];
					//if(abs(a1) < 15){a1 = 0;}
					//if(abs(b1) < 15){b1 = 0;}
					//if(a1*b1 < 0){a1 = 3*a1/5;b1 = 3*b1/5;}
					moveRobot(a1,b1);
					//CraneEncVal = SensorValue[CraneEnc];
					delay(10);
				}
				motorReq[rollerMotor] = 0;
				moveClawsWith(0);
				//go to HVFeeder
				IErr = 0;
				while(!vexRT[Btn5UXmtr2] && goOnFeeder)
				{
					motorReq[rollerMotor] = 30;
					if(vexRT[Btn7D])
					{
						goOnFeeder = false;
						feederMode = false;
					}
					if(vexRT[Btn7L] || vexRT[Btn7R])
					{
						goOnFeeder = false;
						feederMode = false;
						prefeeder = true;
					}
					moveClawsTo(2000);
					if(SensorValue[craneEnc] < craneValsHFeeder[conesCount])
					{
						moveCraneTo(craneValsHFeeder[conesCount]);
					}
					else
					{
						moveCraneWith(0);
					}
					delay(10);
				}
				moveCraneWith(0);
				//claws back
				IErr = 0;
				while(!vexRT[Btn5DXmtr2] && goOnFeeder)
				{
					if(vexRT[Btn7D])
					{
						goOnFeeder = false;
						feederMode = false;
					}
					if(vexRT[Btn7L] || vexRT[Btn7R])
					{
						goOnFeeder = false;
						feederMode = false;
						prefeeder = true;
					}

					if(SensorValue[craneEnc] < craneValsHFeeder[conesCount])
					{
						moveCraneTo(craneValsHFeeder[conesCount]);
					}
					else
					{
						moveCraneWith(0);
					}
					if(SensorValue[clawsPot] < 2300){moveClawsTo(3300);motorReq[rollerMotor] = 30;}
					else{moveClawsWith(0);}
					delay(10);
				}
				//go down to desired position
				moveCraneWith(0);
				IErr = 0;
				while(!vexRT[Btn5UXmtr2] && goOnFeeder)
				{
					if(vexRT[Btn7D])
					{
						goOnFeeder = false;
						feederMode = false;
					}
					if(vexRT[Btn7L] || vexRT[Btn7R])
					{
						goOnFeeder = false;
						feederMode = false;
						prefeeder = true;
					}
					if(SensorValue[craneEnc] > craneVals[conesCount])
					{
						moveCraneTo(craneVals[conesCount]);
					}
					else
					{
						moveCraneWith(0);
					}
					delay(10);
				}
				//eject cone + go to HVFeeder
				clearTimer(T1);
				IErr = 0;
				while(!vexRT[Btn5DXmtr2] && goOnFeeder)
				{
					if(vexRT[Btn7D])
					{
						goOnFeeder = false;
						feederMode = false;
					}
					if(vexRT[Btn7L] || vexRT[Btn7R])
					{
						goOnFeeder = false;
						feederMode = false;
						prefeeder = true;
					}
					if(time1(T1) < 500){
						turnRollerToEject();
					}
					else
					{
						motorReq[rollerMotor] = 0;
						if(SensorValue[craneEnc] < craneValsHFeeder[conesCount])
						{
							moveCraneTo(craneValsHFeeder[conesCount]);
						}
						else
						{
							moveCraneWith(0);
						}
					}
					delay(10);
				}
				//move claws to forward
				IErr = 0;
				while(!vexRT[Btn5UXmtr2] && goOnFeeder)
				{
					if(vexRT[Btn7D])
					{
						goOnFeeder = false;
						feederMode = false;
					}
					if(vexRT[Btn7L] || vexRT[Btn7R])
					{
						goOnFeeder = false;
						feederMode = false;
						prefeeder = true;
					}
					moveClawsTo(2000);
					if(SensorValue[craneEnc] < craneValsHFeeder[conesCount])
					{
						moveCraneTo(craneValsHFeeder[conesCount]);
					}
					else
					{
						moveCraneWith(0);
					}
					delay(10);
				}
				IErr = 0;
				while(true && goOnFeeder)
				{
					moveClawsTo(1800);
					//fieldMode = false;
					if(vexRT[Btn7D])
					{
						goOnFeeder = false;
						feederMode = false;
						break;
					}
					if(vexRT[Btn7L] || vexRT[Btn7R])
					{
						goOnFeeder = false;
						feederMode = false;
						prefeeder = true;
						break;
					}
					if(vexRT[Btn5U])
					{
						if(conesCount < 10)
					{
						conesCount = conesCount + 1;
					}
						break;
					}
					if(vexRT[Btn5D])
					{
						break;
					}
				}
			}
		}

		int a = vexRT[Ch2];
		int b = vexRT[Ch3];
		if(abs(a) < 15){a = 0;}
		if(abs(b) < 15){b = 0;}
		if(a*b < 0){a = 3*a/5;b = 3*b/5;}

		motorReq[frontLeftExp] = b;
		motorReq[backLeft] = b;
		motorReq[frontRight1] = a;
		motorReq[frontRight2] = a;
		motorReq[backRight] = a;

	}
}
void moveClawsTo(int clawsTar)
{
	int Err = SensorValue[clawsPot] - clawsTar;
	moveClawsWith(0.1*Err);
}
void moveClawsWith(int speed)
{
	motorReq[rightClaws] = motorReq[leftClaws] = speed;
}
void moveCraneWith(int speed)
{
	motorReq[craneMotorsExp]= speed;
}
void moveCraneTo(int craneTar)
{
	int Err = -SensorValue[craneEnc] + craneTar;
	moveCraneWith(1.2*Err + 0.00001*IErr);
	if(abs(1.2*Err + 0.00001*IErr) < MAX_CMD)
	{
		IErr = IErr + Err;
	}
}
void moveRobot(int RSpeed, int LSpeed)
{
	motorReq[frontLeftExp] = LSpeed;
	motorReq[backLeft] = LSpeed;
	motorReq[frontRight1] = RSpeed;
	motorReq[frontRight2] = RSpeed;
	motorReq[backRight] = RSpeed;
}
void turnRollerToEat()
{
	motorReq[rollerMotor] = 127;
}
void turnRollerToEject()
{
	motorReq[rollerMotor] = -127;
}
